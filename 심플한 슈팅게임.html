<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>2D 슈팅게임</title>
        <style>
            body {
                font-family: 'Arial', sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                user-select: none;
                margin: 0;
                padding: 0;
                overflow: hidden;
            }

            canvas {
                background: #eee;
                display: block;
                margin: 0 auto;
            }

            #weaponSelect {
                text-align: center;
                margin-bottom: 20px;
            }

            #weaponDescription {
                text-align: center;
                margin-top: 20px;
                font-size: 18px;
            }

            #functionFive {
                text-align: center;
                margin-top: 20px;
                font-size: 20px;
                position: fixed;
                bottom: 10px;
                width: 100%;
            }

            #itemSelection {
                text-align: center;
                margin-top: 20px;
            }

            #selectionModal {
                display: none;
                text-align: center;
                margin-top: 20px;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
            }

            body {
                user-select: none;
            }

            button.common {
                background-color: grey;
            }

            button.rare {
                background-color: cyan;
            }

            button.epic {
                background-color: magenta;
            }

            button.legendary {
                background-color: gold;
            }

            #pauseMenu {
                display: none;
                text-align: center;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
            }

            #pauseMenu button {
                display: block;
                margin: 10px auto;
                padding: 10px 20px;
                font-size: 18px;
                color: black;
            }

            #mainMenu.hidden {
                display: none;
            }

            #gameOverMenu {
                display: none;
                text-align: center;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px;
                border-radius: 10px;
            }

            #gameOverMenu button {
                display: block;
                margin: 10px auto;
                padding: 10px 20px;
                font-size: 18px;
                color: black;
            }

            #playerHealth {
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 18px;
                background-color: rgba(0, 0, 0, 0.5);
                color: white;
                padding: 5px 10px;
                border-radius: 5px;
            }
        </style>
        <script>
            window.onload = function () {
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    alert('이 게임은 모바일을 지원하지 않습니다.');
                }
            };
        </script>
    </head>

    <body oncontextmenu="return false">
        <div id="weaponSelect">
            <h2>무기를 고르다</h2>
            <p>
                <button
                    onmouseover="showDescription('multishot')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('multishot')"
                >
                    다중 발사
                </button>
                <button
                    onmouseover="showDescription('automatic')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('automatic')"
                >
                    자동의
                </button>
                <button
                    onmouseover="showDescription('strike')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('strike')"
                >
                    내려치기
                </button>
                <button
                    onmouseover="showDescription('dual')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('dual')"
                >
                    두개
                </button>
                <button
                    onmouseover="showDescription('swing')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('swing')"
                >
                    휘두르다
                </button>
            </p>
            <p>
                <button
                    onmouseover="showDescription('chain')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('chain')"
                >
                    연쇄
                </button>
                <button
                    onmouseover="showDescription('absorb')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('absorb')"
                >
                    흡수
                </button>
                <button
                    onmouseover="showDescription('burst')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('burst')"
                >
                    터지는 공격
                </button>
                <button
                    onmouseover="showDescription('secondchance')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('secondchance')"
                >
                    두번째 기회
                </button>
                <button
                    onmouseover="showDescription('cycle')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('cycle')"
                >
                    순환
                </button>
                <button
                    onmouseover="showDescription('strongshot')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('strongshot')"
                >
                    강한 샷
                </button>
		<button
                    onmouseover="showDescription('tripleimpact')"
                    onmouseout="hideDescription()"
                    onclick="selectWeapon('tripleimpact')"
                >
                    세번 충격
                </button>
            </p>
        </div>

        <div id="playerHealth"></div>

        <div id="weaponDescription"></div>

        <div id="functionFive">
            <p>WASD : 이동 / 좌클릭 : 공격 / 우클릭 : 방어 / Space : 대시</p>
        </div>

        <div id="selectionModal">
            <div id="itemSelection">
                <h2>아이템을 선택하세요:</h2>
            </div>
            <div id="itemDescription">
                <h2>아이템 설명:</h2>
                <p id="itemDetails"></p>
            </div>
        </div>

        <canvas id="gameCanvas" width="1200" height="800" style="display: none"></canvas>

        <div id="nextStageEnemy" style="text-align: center; margin-top: 20px; display: none">
            <div id="enemyPreview"></div>
        </div>

        <div id="pauseMenu">
            <h2>일시정지</h2>
            <button onclick="resumeGame()">게임 계속하기</button>
            <button onclick="closeTab()">게임 종료</button>
            <h3>휙득한 아이템:</h3>
            <ul id="collectedItemsList"></ul>
        </div>

        <div id="gameOverMenu">
            <h2>게임 오버!</h2>
            <p>당신의 점수: <span id="finalScore"></span></p>
            <h3>휙득한 아이템:</h3>
            <ul id="gameOverItemsList"></ul>
            <button onclick="returnToMainMenu()">메인 메뉴로 돌아가기</button>
        </div>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                updatePlayerHealthDisplay();
            });

            const arr_sound = [];
            const hit = [];

            for (let i = 0; i < 10; i++) {
                const shootmp3 = new Audio('https://lyangnem.github.io/-/shoot.mp3');
                shootmp3.volume = 0.2;

                shootmp3.addEventListener('ended', function () {
                    if (window.chrome) {
                        this.load();
                    }
                    this.pause();
                });

                arr_sound.push(shootmp3);
            }

            document.addEventListener('DOMContentLoaded', function () {
                const itemSelectionDiv = document.getElementById('itemSelection');
            });

            var gameStarted = false;
            var gamePaused = false;
            let isGameLoopRunning = false;
            let gameSpeed = 1;
            let collectedItems = [];
            let selectedWeaponName = '';
            let itemCounts = {};

            function updatePlayerHealthDisplay() {
                const playerHealthDiv = document.getElementById('playerHealth');
                const best_score = localStorage.getItem('best') || 0;

                if (!gameStarted) {
                    playerHealthDiv.innerText = `최고기록 : ${best_score}`;
                    return;
                }

                const damagenow = Math.round(game.player.weapon.damage * 100) / 100;

                if (game.player.weapon.name === '두개') {
                    const explodedamagenow = Math.round(game.player.weapon.damage * 100) / 100;
                    playerHealthDiv.innerText = `체력 : ${game.player.health}/${game.player.maxHealth} | 피해량 : ${damagenow} | 폭발 피해량 : ${explodedamagenow}`;
                } else if (game.player.weapon.name === '터지는 공격') {
                    playerHealthDiv.innerText = `체력 : ${game.player.health}/${game.player.maxHealth} | 폭발 피해량 : ${damagenow}`;
                } else if (game.player.weapon.name === '두번째 기회') {
                    const laserdamagenow = Math.round(game.player.weapon.laserdamage * 100) / 100;
                    playerHealthDiv.innerText = `체력 : ${game.player.health}/${game.player.maxHealth} | 피해량 : ${damagenow} | 레이저 피해량 : ${laserdamagenow}`;
                } else if (game.player.weapon.name === '강한 샷') {
                    const explodedamagenow = Math.round(game.player.weapon.damage * 50) / 100;
                    playerHealthDiv.innerText = `체력 : ${game.player.health}/${game.player.maxHealth} | 피해량 : ${damagenow} | 폭발 피해량 : ${explodedamagenow}`;
                } else if (game.player.weapon.name === '세번 충격') {
                    const explodedamagenow = Math.round(game.player.weapon.damage * 150) / 100;
                    const explodedamagenow2 = Math.round(game.player.weapon.damage * 200) / 100;
                    playerHealthDiv.innerText = `체력 : ${game.player.health}/${game.player.maxHealth} | 피해량 : ${damagenow} | 폭발 피해량 : ${damagenow}/${explodedamagenow}/${explodedamagenow2}`;
                }else {
                    playerHealthDiv.innerText = `체력 : ${game.player.health}/${game.player.maxHealth} | 피해량 : ${damagenow}`;
                }
            }

            if (gameStarted === false) {
                gamePaused = false;
            }

            function startGame() {
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('weaponSelect').style.display = 'block';
            }

            function resumeGame() {
                gamePaused = false;
                document.getElementById('pauseMenu').style.display = 'none';
                game.gameLoop();
            }

            function returnToMainMenu() {
                document.getElementById('pauseModal').style.display = 'none';
                document.getElementById('pauseMenu').style.display = 'none';
                canvas.style.display = 'none';
                document.getElementById('weaponSelect').style.display = 'block';
                document.getElementById('functionFive').style.display = 'block';
                gamePaused = true;
                gameStarted = false;
                game.reset();
                updatePlayerHealthDisplay();
            }

            function showPauseMenu() {
                gamePaused = true;
                const collectedItemsList = document.getElementById('collectedItemsList');
                collectedItemsList.innerHTML = '';
                collectedItems.forEach(item => {
                    const li = document.createElement('li');
                    li.innerText = item.name;
                    collectedItemsList.appendChild(li);
                });
                document.getElementById('pauseMenu').style.display = 'block';
            }

            const sampleItems = {
                speedup: {
                    name: '속도 증가',
                    description: '이동속도가 8% 증가합니다.',
                    rarity: 'common',
                    apply: function () {
                        game.player.speed += game.player.basespeed * 0.08;
                        game.player.defaultSpeed += game.player.basespeed * 0.08;
                        collectedItems.push(this);
                    },
                },
                healthBoost: {
                    name: '체력 회복',
                    description: '플레이어의 체력을 40 회복합니다.',
                    rarity: 'common',
                    apply: function () {
                        if (game.player.maxHealth > game.player.health) {
                            game.player.health = Math.min(game.player.health + 40, game.player.maxHealth);
                            collectedItems.push(this);
                        }
                    },
                },
                chargeDash: {
                    name: '대시 충전',
                    rarity: 'common',
                    description: '플레이어의 대시를 2회 회복합니다.',
                    apply: function () {
                        game.player.dashesLeft = Math.min(game.player.dashesLeft + 2, game.player.maxDashes);
                        collectedItems.push(this);
                    },
                },
                damageBoost: {
                    name: '공격력 강화',
                    description: '무기의 데미지를 8% 증가시킵니다.',
                    rarity: 'common',
                    apply: function () {
                        if (game.player.weapon) {
                            game.player.weapon.damage += game.player.weapon.basedamage * 0.08;
                            game.player.weapon.Edamage += game.player.weapon.baseEdamage * 0.08;
                            game.weapons.secondchance.laserdamage += game.player.weapon.baselaserdamage * 0.08;
                            collectedItems.push(this);
                        }
                    },
                },
                moreHealth: {
                    name: '더 많은 체력',
                    description: '최대 체력이 40 증가합니다.',
                    rarity: 'rare',
                    apply: function () {
                        game.player.maxHealth += 40;
                        game.player.health = Math.min(game.player.health + 40, game.player.maxHealth);
                        collectedItems.push(this);
                    },
                },
                dashBoost: {
                    name: '대시 부스트',
                    rarity: 'rare',
                    description: '대시를 3개 회복하며, 대시 최대치가 1개 증가합니다.',
                    apply: function () {
                        game.player.maxDashes = game.player.maxDashes + 1;
                        game.player.dashesLeft = Math.min(game.player.dashesLeft + 3, game.player.maxDashes);
                        collectedItems.push(this);
                    },
                },
                monstrance: {
                    name: '후광',
                    description: '공격 시 주변 적에게 공격력의 10%의 피해를 줍니다.',
                    rarity: 'rare',
                    apply: function () {
                        collectedItems.push(this);
                        game.player.has_monstrance += 1;
                    },
                },
                damageBoostpack: {
                    name: '공격력 강화 팩',
                    description: '무기의 데미지를 12% 증가시킵니다.',
                    rarity: 'epic',
                    apply: function () {
                        if (game.player.weapon) {
                            game.player.weapon.damage += game.player.weapon.basedamage * 0.12;
                            game.player.weapon.Edamage += game.player.weapon.baseEdamage * 0.12;
                            game.weapons.secondchance.laserdamage += game.weapons.secondchance.baselaserdamage * 0.12;
                            collectedItems.push(this);
                        }
                    },
                },
                bulletspeedtBoost: {
                    name: '부스터 탄환',
                    description: '탄속이 20% 증가합니다.',
                    rarity: 'rare',
                    apply: function () {
                        if (game.player.weapon) {
                            game.player.weapon.speed += game.player.weapon.basespeed * 0.2;
                            game.player.weapon.cyclesecond -= game.player.weapon.basecyclesecond * 0.2;
                            game.player.weapon.Ecyclesecond -= game.player.weapon.baseEcyclesecond * 0.2;
                            if (game.player.weapon.cyclesecond < 1) {
                                game.player.weapon.cyclesecond = 1;
                            }
                            if (game.player.weapon.Ecyclesecond < 1) {
                                game.player.weapon.Ecyclesecond = 1;
                            }
                            collectedItems.push(this);
                        }
                    },
                },
                cure: {
                    name: '완치',
                    description: '체력을 150 및 대시를 4 회복하며, 방어 쿨타임이 초기화됩니다.',
                    rarity: 'epic',
                    apply: function () {
                        game.player.health = Math.min(game.player.health + 150, game.player.maxHealth);
                        game.player.dashesLeft = Math.min(game.player.dashesLeft + 4, game.player.maxDashes);
                        game.player.parryCooldown = 0;
                        collectedItems.push(this);
                    },
                },
                healingBox: {
                    name: '치료상자',
                    description: '체력을 80 회복하며, 최대체력을 50 증가시킵니다.',
                    rarity: 'epic',
                    apply: function () {
                        game.player.maxHealth += 50;
                        game.player.health = Math.min(game.player.health + 130, game.player.maxHealth);
                        collectedItems.push(this);
                    },
                },
                controlRecoil: {
                    name: '반동제어',
                    description: '공격속도가 10% 빨라집니다.',
                    rarity: 'epic',
                    apply: function () {
                        game.player.weapon.cooldown -= game.player.weapon.basecooldown * 0.1;
                        if (game.player.weapon.cooldown < 1) {
                            game.player.weapon.cooldown = 1;
                        }
                        collectedItems.push(this);
                    },
                },
                speedBoost: {
                    name: '빠른 움직임',
                    description: '이동속도가 12% 빨라집니다.',
                    rarity: 'rare',
                    apply: function () {
                        game.player.speed += game.player.basespeed * 0.12;
                        game.player.defaultSpeed += game.player.basespeed * 0.12;
                        collectedItems.push(this);
                    },
                },
                lastdance: {
                    name: '마지막 춤',
                    description: '체력이 30% 아래로 내려가면 피해량 증가 35%를 부여받습니다.',
                    rarity: 'epic',
                    apply: function () {
                        if (game.player.lastDanceApplied === true) {
                            game.player.weapon.damage -=
                                game.player.weapon.basedamage * 0.35 * game.player.lastDanceCount;
                            game.player.weapon.Edamage -=
                                game.player.weapon.baseEdamage * 0.35 * game.player.lastDanceCount;
                            game.player.weapon.laserdamage -=
                                game.player.weapon.baselaserdamage * 0.35 * game.player.lastDanceCount;
                            game.player.lastDanceApplied = false;
                        }
                        game.player.lastDanceCount += 1;
                        collectedItems.push(this);
                    },
                },
                parryBoost: {
                    name: '쿨다운 가속',
                    description: '쉴드의 초당 쿨다운 속도가 0.7초 빨라집니다.',
                    rarity: 'legendary',
                    apply: function () {
                        game.player.parryCooldownspeed += game.player.baseparryCooldownspeed * 0.7;
                        collectedItems.push(this);
                    },
                },
                critical: {
                    name: '치명타',
                    description: '탄속 및 피해량이 18% 증가합니다.',
                    rarity: 'legendary',
                    apply: function () {
                        game.player.weapon.damage += game.player.weapon.basedamage * 0.18;
                        game.player.weapon.Edamage += game.player.weapon.baseEdamage * 0.18;
                        game.weapons.secondchance.laserdamage += game.weapons.secondchance.baselaserdamage * 0.18;
                        game.player.weapon.speed += game.player.weapon.basespeed * 0.18;
                        game.player.weapon.cyclesecond -= game.player.weapon.basecyclesecond * 0.18;
                        game.player.weapon.Ecyclesecond -= game.player.weapon.baseEcyclesecond * 0.18;
                        if (game.player.weapon.cyclesecond < 1) {
                            game.player.weapon.cyclesecond = 1;
                        }
                        if (game.player.weapon.Ecyclesecond < 1) {
                            game.player.weapon.Ecyclesecond = 1;
                        }
                        collectedItems.push(this);
                    },
                },
                speedup: {
                    name: '속도 증가',
                    description: '이동속도가 8% 증가합니다.',
                    rarity: 'common',
                    apply: function () {
                        game.player.speed += game.player.basespeed * 0.08;
                        game.player.defaultSpeed += game.player.basespeed * 0.08;
                        collectedItems.push(this);
                    },
                },
                weaponBoost: {
                    name: '전용 강화',
                    description: '현재 무기에는 특별한 스킬이 없습니다.',
                    rarity: 'legendary',
                    update: function (weaponName) {
                        if (weaponName === 'multishot') {
                            this.name = '자동조준';
                            this.description =
                                '[ 다중 발사 전용 ]\n가장 가까운 적을 향해 총알을 50% 추가로 발사합니다.';
                        } else if (weaponName === 'automatic') {
                            this.name = '피어스';
                            this.description = '[ 자동의 전용 ]\n탄환이 한명의 적을 관통합니다.';
                        } else if (weaponName === 'strike') {
                            this.name = '파괴적인';
                            this.description =
                                '[ 내려치기 전용 ]\n내려치기의 공격 범위가 10%, 피해량이 20% 증가합니다.';
                        } else if (weaponName === 'dual') {
                            this.name = '세개';
                            this.description = '[ 두개 전용 ]\n탄환의 개수가 1개 증가합니다.';
                        } else if (weaponName === 'swing') {
                            this.name = '그것은 매우 강한!';
                            this.description = '[ 휘두르다 전용 ]\n공격 범위가 15% 증가합니다.';
                        } else if (weaponName === 'chain') {
                            this.name = '추가 연쇄';
                            this.description = '[ 연쇄 전용 ]\n탄환의 연쇄되는 적의 수가 1명 증가합니다.';
                        } else if (weaponName === 'absorb') {
                            this.name = '영양 균형';
                            this.description = '[ 흡수 전용 ]\n최대체력 증가량이 0.5, 회복량이 1 증가합니다.';
                        } else if (weaponName === 'burst') {
                            this.name = '범위가 넓은';
                            this.description = '[ 터지는 공격 전용 ]\n탄속과 공격 범위, 피해량이 25% 증가합니다.';
                        } else if (weaponName === 'secondchance') {
                            this.name = '파괴광선';
                            this.description =
                                '[ 두번째 기회 전용 ]\n레이저의 크기가 35%, 레이저 피해량이 15% 증가합니다.';
                        } else if (weaponName === 'cycle') {
                            this.name = '주기 감소';
                            this.description = '[ 순환 전용 ]\n순환구가 1개 증가합니다.';
                        } else if (weaponName === 'strongshot') {
                            this.name = '튕긴 샷';
                            this.description =
                                '[ 강한 샷 전용 ]\n탄환이 벽에 부딪히면 최대 한명의 적을 관통할 수 있는 상태로 반사됩니다.';
                        } else if (weaponName === 'tripleimpact') {
                            this.name = '충격적인';
                            this.description = '[ 세번 충격 전용 ]\n탄환의 크기가 40% 작아지고 피해량이 18% 증가합니다.';
                        } else {
                            this.name = '전용 강화';
                            this.description = '현재 무기에는 특별한 스킬이 없습니다.';
                        }
                    },
                    apply: function () {
                        if (selectedWeaponName === 'multishot') {
                            game.weapons.multishot.dualSpreadCount += game.weapons.multishot.spread * 0.5;
                        } else if (selectedWeaponName === 'automatic') {
                            game.weapons.automatic.pierce += 1;
                        } else if (selectedWeaponName === 'strike') {
                            game.weapons.strike.damage += game.weapons.strike.basedamage * 0.2;
                            game.weapons.strike.range += game.weapons.strike.baserange * 0.1;
                        } else if (selectedWeaponName === 'dual') {
                            game.weapons.dual.bullets += 1;
                        } else if (selectedWeaponName === 'swing') {
                            game.weapons.swing.range += game.weapons.swing.baserange * 0.15;
                        } else if (selectedWeaponName === 'chain') {
                            game.weapons.chain.chaincount += 1;
                        } else if (selectedWeaponName === 'absorb') {
                            game.weapons.absorb.valueMax += 0.5;
                            game.weapons.absorb.value += 1;
                        } else if (selectedWeaponName === 'burst') {
                            game.weapons.burst.explosiverange += game.weapons.burst.baseexplosiverange * 0.25;
                            game.weapons.burst.speed += game.weapons.burst.basespeed * 0.25;
                            game.weapons.burst.damage += game.weapons.burst.basedamage * 0.25;
                        } else if (selectedWeaponName === 'secondchance') {
                            game.weapons.secondchance.laserthickness +=
                                game.weapons.secondchance.baselaserthickness * 0.35;
                            game.weapons.secondchance.laserdamage += game.weapons.secondchance.baselaserdamage * 0.15;
                        } else if (selectedWeaponName === 'cycle') {
                            game.weapons.cycle.cyclecount += 1;
                            `game.weapons.cycle.cycledistance -= game.weapons.cycle.basecycledistance * 0.08;
                        game.weapons.cycle.Ecycledistance -= game.weapons.cycle.baseEcycledistance * 0.08;
                        if (game.player.weapon.Ecycledistance < 8) {
                            game.player.weapon.Ecycledistance = 8;
                        }
                        if (game.player.weapon.cycledistance < 8) {
                            game.player.weapon.cycledistance = 8;
                        }`;
                        } else if (selectedWeaponName === 'strongshot') {
                            game.weapons.strongshot.maxReflections += 1;
                            game.weapons.strongshot.reflectionpierce += 1;
                        } else if (selectedWeaponName === 'tripleimpact') {
                            game.weapons.tripleimpact.damage += game.weapons.tripleimpact.basedamage * 0.18;
                            game.weapons.tripleimpact.radius -= game.weapons.tripleimpact.baseradius * 0.4;
                            if (game.weapons.tripleimpact.radius < 1) {
                                game.weapons.tripleimpact.radius = 1;
                            }
                        }
                        collectedItems.push(this);
                    },
                },
            };

            function updateWeaponBoostItem(item) {
                item.update(selectedWeaponName);
            }

            function selectWeapon(weaponName) {
                game.player.selectWeapon(weaponName);
                gameStarted = true;
                selectedWeaponName = weaponName;
            }

            let stage = 1;
            let baseStageScore = 1500;
            let stageIncrement = 200;

            function updateStage() {
                let requiredScore = 0;
                for (let i = 1; i <= stage; i++) {
                    requiredScore += baseStageScore + (i - 1) * stageIncrement;
                }
                if (score >= requiredScore) {
                    stage++;
                    gamePaused = true;
                    showStageAndItemSelection(stage);
                    updateNextStageEnemy();
                }
            }

            function showStageAndItemSelection(stage) {
                gamePaused = true;

                const selectionModal = document.getElementById('selectionModal');
                selectionModal.innerHTML =
                    '<div id="itemSelection">\n<h2>아이템을 선택하세요:</h2>\n</div>\n<div id="itemDescription">\n<h2>아이템 설명:</h2>\n<p id="itemDetails"></p>\n</div>';
                selectionModal.insertAdjacentHTML('afterbegin', `<h2>Stage ${stage}</h2>`);

                const itemSelectionDiv = document.getElementById('itemSelection');
                itemSelectionDiv.innerHTML = '';

                const selectedItems = [];
                const itemKeys = Object.keys(sampleItems);
                const usedKeys = new Set();

                const rarityWeights = {
                    common: 0.4,
                    rare: 0.3,
                    epic: 0.2,
                    legendary: 0.1,
                };

                function getRandomItem() {
                    let totalWeight = 0;
                    const weightedItems = [];

                    itemKeys.forEach(key => {
                        const item = sampleItems[key];
                        if (!item || !item.rarity || usedKeys.has(key)) return;
                        const weight = rarityWeights[item.rarity];
                        totalWeight += weight;
                        weightedItems.push({
                            key,
                            weight,
                        });
                    });

                    const random = Math.random() * totalWeight;
                    let currentWeight = 0;

                    for (let i = 0; i < weightedItems.length; i++) {
                        currentWeight += weightedItems[i].weight;
                        if (random < currentWeight) {
                            usedKeys.add(weightedItems[i].key);
                            return weightedItems[i].key;
                        }
                    }

                    return null;
                }

                while (selectedItems.length < 3) {
                    const randomKey = getRandomItem();
                    if (randomKey) {
                        const item = {
                            ...sampleItems[randomKey],
                        };
                        if (randomKey === 'weaponBoost') {
                            updateWeaponBoostItem(item);
                        }
                        selectedItems.push(item);
                    }
                }

                selectedItems.forEach(item => {
                    const itemButton = document.createElement('button');
                    itemButton.innerText = item.name;

                    if (item.rarity === 'common') {
                        itemButton.classList.add('common');
                    } else if (item.rarity === 'rare') {
                        itemButton.classList.add('rare');
                    } else if (item.rarity === 'epic') {
                        itemButton.classList.add('epic');
                    } else if (item.rarity === 'legendary') {
                        itemButton.classList.add('legendary');
                    }

                    itemButton.onclick = () => {
                        item.apply();
                        hideSelectionModal();
                        gamePaused = false;
                        game.gameLoop();
                    };
                    itemButton.onmouseover = () => {
                        document.getElementById('itemDetails').innerText = item.description;
                    };
                    itemSelectionDiv.appendChild(itemButton);
                });

                itemSelectionDiv.style.display = 'block';
                document.getElementById('itemDescription').style.display = 'block';
                selectionModal.style.display = 'block';
            }

            function hideSelectionModal() {
                const selectionModal = document.getElementById('selectionModal');
                selectionModal.style.display = 'none';
                document.getElementById('itemSelection').style.display = 'none';
                document.getElementById('itemDescription').style.display = 'none';
            }

            function updateNextStageEnemy() {
                const enemyPreview = document.getElementById('enemyPreview');
                let enemyTypes = Object.keys(game.enemyTypes);
                let nextEnemyType = enemyTypes[stage % enemyTypes.length];
                let enemy = game.enemyTypes[nextEnemyType];

                const enemyNamesInKorean = {
                    basic: '기본 적',
                    fast: '빠른 적',
                    tank: '탱크 적',
                    sniper: '저격 적',
                    buffer: '버프 적',
                    debuffer: '디버프 적',
                    explosive: '자폭 적',
                    assassin: '암살 적',
                    splitter: '분열 적',
                    charger: '차징 적',
                };

                enemyPreview.innerHTML = `
        <h2>다음 스테이지의 적 : ${enemyNamesInKorean[nextEnemyType]}</h2>
        <div style="display:inline-block; width:50px; height:50px; background-color:${enemy.color}; border-radius:50%;"></div>
    `;
            }

            function resetEventListeners() {
                canvas.removeEventListener('mousedown', handleMouseDown);
                canvas.removeEventListener('mouseup', handleMouseUp);
                canvas.removeEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('mousemove', handleMouseMove);
            }

            function handleMouseDown(e) {
                if (e.button === 0) {
                    mouseDown = true;
                    game.player.attack();
                } else if (e.button === 2) {
                    mouseDown2 = true;
                    game.player.parry();
                }
            }

            function handleMouseUp(e) {
                if (e.button === 0) {
                    mouseDown = false;
                } if (e.button === 2) {
                    mouseDown2 = false;
                }
            }

            function handleMouseMove(e) {
                let rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            }

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            let mouseX = 0,
                mouseY = 0;
            let mouseDown = false;
            let mouseDown2 = false;
            const keys = {};
            let score = 0;
            let summonSpeed = 120;

            const game = {
                summonSpeed: 120,
                summonSpeedDecreaseInterval: 100,
                minSummonSpeed: 0.03,
                lasers: [],
                isPaused: false,

                pauseGame: function () {
                    this.isPaused = true;
                },

                resumeGame: function () {
                    this.isPaused = false;
                    this.gameLoop();
                },

                handleExplosion: function (x, y, damage, explosionRadius, source, weapon) {
                    let maxDamage = damage;
                    let minDamage = damage * 0.5;

                    game.effects.createExplosionEffect(x, y, explosionRadius);

                    if (source === 'enemy') {
                        if (
                            game.utils.circleCollision(
                                {
                                    x: x,
                                    y: y,
                                    radius: explosionRadius,
                                },
                                game.player
                            )
                        ) {
                            if (!game.player.isParrying && !game.player.isDashing) {
                                game.player.health -= damage;
                                if (game.player.health <= 0) {
                                    showGameOverScreen();
                                }
                            }
                        }
                    } else if (source === 'weapon') {
                        game.enemies.forEach((enemy, index) => {
                            let dist = Math.sqrt((enemy.x - x) ** 2 + (enemy.y - y) ** 2);
                            if (dist < explosionRadius) {
                                let dmg = damage;
                                if (weapon === 'burst') {
                                    dmg = minDamage + (maxDamage - minDamage) * (1 - dist / explosionRadius);
                                } else if (weapon === 'dual') {
                                    dmg = damage;
                                } else if (weapon === 'strongshot') {
                                    dmg = game.weapons.strongshot.damage * 0.5;
                                } else if (weapon === 'tripleimpact') {
                                    dmg = damage;
                                }
                                enemy.health -= dmg;
                                if (enemy.health <= 0) {
                                    enemy.handleDeath(index);
                                } else {
                                    enemy.healthBarVisible = true;
                                }
                            }
                        });
                    }
                },

                handleLaser: function (bulletX, bulletY, dx, dy, damage, hitEnemies) {
                    const bulletAngle = Math.atan2(dy, dx);
                    const laserDX = Math.cos(bulletAngle);
                    const laserDY = Math.sin(bulletAngle);

                    game.lasers.push({
                        x: bulletX,
                        y: bulletY,
                        dx: laserDX,
                        dy: laserDY,
                        angle: bulletAngle,
                        damage: damage,
                        duration: 15,
                        hitEnemies: Array.isArray(hitEnemies) ? hitEnemies : [],
                        width: game.weapons.secondchance.laserthickness,
                    });
                },

                drawLaser: function (laser) {
                    ctx.beginPath();
                    ctx.moveTo(laser.x, laser.y);
                    ctx.lineTo(laser.x + laser.dx * 2000, laser.y + laser.dy * 2000);
                    ctx.strokeStyle = game.player.color;
                    ctx.lineWidth = laser.width; // 레이저 두께
                    ctx.stroke();
                    ctx.closePath();
                },

                handleSwordEffectCollision: function (effect) {
                    game.enemies.forEach((enemy, index) => {
                        // 충돌 검사
                        if (game.utils.circleCollision(effect, enemy)) {
                            enemy.health -= game.player.weapon.damage;
                            if (enemy.health <= 0) {
                                enemy.handleDeath(index);
                            } else {
                                enemy.healthBarVisible = true;
                            }
                        }
                    });
                },
                handleSwordEffectDamage: function (x, y, radius) {
                    const effect = {
                        x: x,
                        y: y,
                        radius: radius,
                    };
                    if (game.player.weapon.name === '휘두르다') {
                        game.enemyBullets = game.enemyBullets.filter((bullet, index) => {
                            if (game.utils.circleCollision(effect, bullet)) {
                                return false;
                            }
                            return true;
                        });
                    }
                    game.enemies.forEach((enemy, index) => {
                        if (game.utils.circleCollision(effect, enemy)) {
                            enemy.health -= game.player.weapon.damage;
                            if (enemy.health <= 0) {
                                enemy.handleDeath(index);
                            } else {
                                enemy.healthBarVisible = true;
                            }
                        }
                    });
                },
                handleSwordEffectDamageOfMonstrance: function (x, y, radius) {
                    const effect = {
                        x: x,
                        y: y,
                        radius: radius,
                    };
                    game.enemies.forEach((enemy, index) => {
                        if (game.utils.circleCollisionOfMonstrance(effect, enemy)) {
                            enemy.health -= game.player.weapon.damage * 0.15 * game.player.has_monstrance;
                            if (enemy.health <= 0) {
                                enemy.handleDeath(index);
                            } else {
                                enemy.healthBarVisible = true;
                            }
                        }
                    });
                },
                player: {
                    x: canvas.width / 2,
                    y: canvas.height - 30,
                    radius: 20,
                    color: 'hsl(195, 70%, 60%)',
                    defaultColor: 'hsl(195, 70%, 60%)',
                    health: 100,
                    maxHealth: 100,
                    isParrying: false,
                    parryDuration: 0,
                    parryCooldown: 0,
                    parryCooldownspeed: 1,
                    baseparryCooldownspeed: 1,
                    parryHits: 0,
                    basespeed: 4,
                    basedefaultSpeed: 4,
                    speed: 4,
                    defaultSpeed: 4,
                    weapon: null,
                    dashesLeft: 5,
                    maxDashes: 5,
                    isDashing: false,
                    dashDuration: 0,
                    hitDuration: 0,
                    isDebuffed: false,
                    debuffColor: null,
                    debuffDuration: 0,
                    lastDanceCount: 0,
                    lastDanceApplied: false,
                    has_monstrance: 0,

                    selectWeapon: function (weaponName) {
                        this.weapon = game.weapons[weaponName];
                        console.log('Selected weapon:', this.weapon);
                        document.getElementById('weaponSelect').style.display = 'none';
                        document.getElementById('functionFive').style.display = 'none';
                        document.getElementById('nextStageEnemy').style.display = 'block';
                        canvas.style.display = 'block';
                        updateNextStageEnemy();
                        gamePaused = false;
                        game.gameLoop();
                    },

                    update: function () {
                        this.handleMovement();
                        this.handleStatus();

                        if (this.lastDanceCount > 0 && !this.lastDanceApplied && this.health <= this.maxHealth * 0.3) {
                            game.player.weapon.damage += game.player.weapon.basedamage * 0.35 * this.lastDanceCount;
                            game.player.weapon.Edamage += game.player.weapon.baseEdamage * 0.35 * this.lastDanceCount;
                            game.player.weapon.laserdamage +=
                                game.player.weapon.baselaserdamage * 0.35 * this.lastDanceCount;
                            this.lastDanceApplied = true;
                        }
                        if (this.lastDanceCount > 0 && this.lastDanceApplied && this.health > this.maxHealth * 0.3) {
                            game.player.weapon.damage -= game.player.weapon.basedamage * 0.35 * this.lastDanceCount;
                            game.player.weapon.Edamage -= game.player.weapon.baseEdamage * 0.35 * this.lastDanceCount;
                            game.player.weapon.laserdamage -=
                                game.player.weapon.baselaserdamage * 0.35 * this.lastDanceCount;
                            this.lastDanceApplied = false;
                        }

                        updatePlayerHealthDisplay();
                        if (this.health <= 0) {
                            gameOver();
                        }
                    },

                    handleMovement: function () {
                        if (keys['w'] && this.y - this.radius > 0)
                            this.y -= this.isDashing ? this.speed * 3 : this.speed;
                        if (keys['s'] && this.y + this.radius < canvas.height)
                            this.y += this.isDashing ? this.speed * 3 : this.speed;
                        if (keys['a'] && this.x - this.radius > 0)
                            this.x -= this.isDashing ? this.speed * 3 : this.speed;
                        if (keys['d'] && this.x + this.radius < canvas.width)
                            this.x += this.isDashing ? this.speed * 3 : this.speed;

                        if (this.isDashing) {
                            this.dashDuration--;
                            if (this.dashDuration <= 0) {
                                this.isDashing = false;
                            }
                        }
                    },

                    handleStatus: function () {
                        if (this.isParrying) {
                            this.parryDuration--;
                            if (this.parryDuration <= 0) {
                                this.isParrying = false;
                                this.parryCooldown += this.parryHits * 180;
                                this.parryHits = 0;
                            }
                        } else if (this.parryCooldown > 0) {
                            this.parryCooldown -= game.player.parryCooldownspeed;
                            if (this.parryCooldown < 0) {
                                this.parryCooldown = 0;
                            }
                        }

                        if (this.hitDuration > 0) {
                            this.hitDuration--;
                            if (this.hitDuration === 0) {
                                this.color = this.defaultColor;
                            }
                        }

                        // 디버프 상태 해제
                        if (this.isDashing || this.isParrying) {
                            this.isDebuffed = false;
                            this.debuffColor = null;
                            this.speed = this.defaultSpeed;
                            this.debuffDuration = 0;
                        }

                        // 디버프 상태 지속시간
                        if (this.debuffDuration > 0) {
                            this.debuffDuration--;
                            if (this.debuffDuration === 0) {
                                this.isDebuffed = false;
                                this.debuffColor = null;
                                this.speed = this.defaultSpeed;
                            }
                        }
                    },

                    dash: function () {
                        if (this.dashesLeft > 0) {
                            this.isDashing = true;
                            this.dashDuration = 15;
                            this.dashesLeft--;
                        }
                    },

                    parry: function () {
                        if (!this.isParrying && this.parryCooldown === 0) {
                            this.isParrying = true;
                            this.parryDuration = 45;
                        }
                    },

                    attack: function () {
                        let now = Date.now();
                        if (this.weapon.lastShot + this.weapon.cooldown > now) return;

                        for (let i = 0; i < 10; i++) {
                            if (arr_sound[i].paused) {
                                arr_sound[i].play();
                                break;
                            }
                        }

                        let dx = mouseX - this.x;
                        let dy = mouseY - this.y;
                        let angle = Math.atan2(dy, dx);

                        if (this.has_monstrance >= 1) {
                            game.effects.createSwordEffect(this.x, this.y, 130);
                            game.handleSwordEffectDamageOfMonstrance(this.x, this.y, 130);
                        }

                        if (this.weapon.name === '내려치기') {
                            game.effects.createSwordEffect(mouseX, mouseY, game.weapons.strike.range);
                            game.handleSwordEffectDamage(mouseX, mouseY, game.weapons.strike.range);
                        } else if (this.weapon.name === '휘두르다') {
                            game.effects.createSwordEffect(this.x, this.y, game.weapons.swing.range);
                            game.handleSwordEffectDamage(this.x, this.y, game.weapons.swing.range);
                        } else {
                            this.weapon.attack(angle);
                        }

                        this.weapon.lastShot = now;
                    },

                    draw: function () {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fillStyle = this.isDashing ? 'hsl(195, 70%, 70%)' : this.color;
                        ctx.fill();
                        ctx.strokeStyle = this.isParrying
                            ? 'blue'
                            : this.isDebuffed
                            ? this.debuffColor
                            : 'hsl(195, 70%, 75%)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.closePath();
                    },

                    drawUI: function () {
                        ctx.fillStyle = 'red';
                        ctx.fillRect(
                            this.x - this.radius,
                            this.y + this.radius + 10,
                            this.radius * 2 * (this.health / 100),
                            5
                        );
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(
                            this.x - this.radius,
                            this.y + this.radius + 20,
                            this.radius * 2 * (this.parryCooldown / 300),
                            5
                        );
                        ctx.fillStyle = 'green';
                        ctx.fillRect(
                            this.x - this.radius,
                            this.y + this.radius + 30,
                            this.radius * 2 * (this.dashesLeft / 5),
                            5
                        );
                    },
                },

                weapons: {
                    multishot: {
                        name: '다중 발사',
                        basedamage: 40,
                        basespeed: 10,
                        basecooldown: 500,
                        damage: 40,
                        speed: 10,
                        spread: 6,
                        cooldown: 500,
                        color: 'hsl(30, 70%, 60%)',
                        lastShot: 0,
                        dualSpreadCount: 0,
                        attack: function (angle) {
                            let closestEnemy = null;
                            let closestDistance = Infinity;

                            game.enemies.forEach(enemy => {
                                let dx = enemy.x - game.player.x;
                                let dy = enemy.y - game.player.y;
                                let dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < closestDistance) {
                                    closestDistance = dist;
                                    closestEnemy = enemy;
                                }
                            });

                            for (let i = 0; i < this.spread; i++) {
                                let spreadAngle = angle + (Math.random() - 0.5) * 0.3;
                                game.bullets.push({
                                    x: game.player.x,
                                    y: game.player.y,
                                    radius: 5,
                                    color: game.player.color,
                                    speed: this.speed,
                                    dx: Math.cos(spreadAngle),
                                    dy: Math.sin(spreadAngle),
                                    damage: this.damage,
                                });
                            }
                            for (let i = 0; i < this.dualSpreadCount; i++) {
                                if (closestEnemy) {
                                    let baseAngle = Math.atan2(
                                        closestEnemy.y - game.player.y,
                                        closestEnemy.x - game.player.x
                                    );
                                    let spreadAngle = baseAngle + (Math.random() - 0.5) * 0.3;

                                    game.bullets.push({
                                        x: game.player.x,
                                        y: game.player.y,
                                        radius: 5,
                                        color: game.player.color,
                                        speed: this.speed,
                                        dx: Math.cos(spreadAngle),
                                        dy: Math.sin(spreadAngle),
                                        damage: this.damage,
                                    });
                                }
                            }
                        },
                    },
                    automatic: {
                        name: '자동의',
                        basedamage: 60,
                        basespeed: 20,
                        basecooldown: 100,
                        damage: 60,
                        speed: 20,
                        spread: 0.1,
                        cooldown: 100,
                        color: 'hsl(0, 0%, 70%)',
                        lastShot: 0,
                        pierce: 0,
                        attack: function (angle) {
                            for (let i = 0; i < this.spread; i++) {
                                let spreadAngle = angle + (Math.random() - 0.5) * 0.1;
                                game.bullets.push({
                                    x: game.player.x,
                                    y: game.player.y,
                                    radius: 12.5,
                                    color: game.player.color,
                                    speed: this.speed,
                                    dx: Math.cos(spreadAngle),
                                    dy: Math.sin(spreadAngle),
                                    damage: this.damage,
                                    initialX: game.player.x,
                                    initialY: game.player.y,
                                    timeToLive: 100,
                                    pierce: this.pierce,
                                });
                            }
                        },
                    },
                    strike: {
                        name: '내려치기',
                        basedamage: 100,
                        basespeed: 0,
                        basecooldown: 400,
                        baserange: 60,
                        damage: 100,
                        speed: 0,
                        spread: 0,
                        cooldown: 400,
                        color: 'hsl(0, 0%, 75%)',
                        lastShot: 0,
                        range: 60,
                        attack: function (angle) {
                            // 내려치기는 탄환이 없음
                        },
                    },
                    dual: {
                        name: '두개',
                        basedamage: 20,
                        basespeed: 15,
                        basecooldown: 250,
                        baseexplosiverange: 40,
                        damage: 20,
                        speed: 15,
                        spread: 0,
                        cooldown: 250,
                        color: 'hsl(120, 70%, 60%)',
                        lastShot: 0,
                        bullets: 2,
                        baseBulletSpacing: 25,
                        baseBulletRadius: 10,
                        explosiverange: 40,
                        attack: function (angle) {
                            const anglePerpendicular = angle + Math.PI / 2;
                            const spacingFactor = 1.5 / this.bullets;
                            const radiusFactor = 1.5 / Math.sqrt(this.bullets);

                            for (let i = 0; i < this.bullets; i++) {
                                const offsetMultiplier =
                                    (i - (this.bullets - 1) / 2) * this.baseBulletSpacing * spacingFactor;
                                const bulletRadius = this.baseBulletRadius * radiusFactor;

                                game.bullets.push({
                                    x: game.player.x + offsetMultiplier * Math.cos(anglePerpendicular),
                                    y: game.player.y + offsetMultiplier * Math.sin(anglePerpendicular),
                                    radius: bulletRadius,
                                    color: game.player.color,
                                    speed: this.speed,
                                    dx: Math.cos(angle),
                                    dy: Math.sin(angle),
                                    damage: this.damage,
                                    explosive: 'dual',
                                    hitEnemies: [],
                                });
                            }
                        },
                    },
                    swing: {
                        name: '휘두르다',
                        basedamage: 200,
                        basespeed: 0,
                        basecooldown: 350,
                        baserange: 150,
                        damage: 200,
                        speed: 0,
                        spread: 0,
                        cooldown: 350,
                        color: 'hsl(60, 70%, 60%)',
                        lastShot: 0,
                        range: 150,
                        attack: function (angle) {
                            // 휘두르다는 탄환이 없음
                        },
                    },
                    chain: {
                        name: '연쇄',
                        basedamage: 60,
                        basespeed: 12,
                        basecooldown: 600,
                        damage: 60,
                        speed: 12,
                        spread: 1,
                        chaincount: 4,
                        cooldown: 600,
                        color: 'hsl(210, 70%, 60%)',
                        lastShot: 0,
                        attack: function (angle) {
                            game.bullets.push({
                                x: game.player.x,
                                y: game.player.y,
                                radius: 10,
                                color: game.player.color,
                                speed: this.speed,
                                dx: Math.cos(angle),
                                dy: Math.sin(angle),
                                damage: this.damage,
                                chain: this.chaincount,
                                hitEnemies: [],
                                target: null,
                                originalDamage: this.damage,
                                chainStep: 1,
                            });
                        },
                    },
                    absorb: {
                        name: '흡수',
                        basedamage: 50,
                        basespeed: 15,
                        basecooldown: 550,
                        damage: 50,
                        speed: 15,
                        cooldown: 350,
                        color: 'hsl(300, 70%, 60%)',
                        lastShot: 0,
                        value: 3,
                        valueMax: 3,
                        attack: function (angle) {
                            game.bullets.push({
                                x: game.player.x,
                                y: game.player.y,
                                radius: 10,
                                color: game.player.color,
                                speed: this.speed,
                                dx: Math.cos(angle),
                                dy: Math.sin(angle),
                                damage: this.damage,
                                absorb: true,
                            });
                        },
                    },
                    burst: {
                        name: '터지는 공격',
                        basedamage: 350,
                        basespeed: 10,
                        basecooldown: 850,
                        baseexplosiverange: 150,
                        damage: 350,
                        speed: 10,
                        cooldown: 1000,
                        color: 'hsl(0, 70%, 60%)',
                        lastShot: 0,
                        explosiverange: 150,
                        attack: function (angle) {
                            game.bullets.push({
                                x: game.player.x,
                                y: game.player.y,
                                radius: 15,
                                color: game.player.color,
                                speed: this.speed,
                                dx: Math.cos(angle),
                                dy: Math.sin(angle),
                                damage: this.damage,
                                explosive: 'burst',
                            });
                        },
                    },
                    secondchance: {
                        name: '두번째 기회',
                        basedamage: 80,
                        baselaserdamage: 50,
                        baselaserthickness: 50,
                        basespeed: 20,
                        basecooldown: 700,
                        damage: 80,
                        laserdamage: 50,
                        laserthickness: 50,
                        speed: 20,
                        cooldown: 700,
                        color: 'hsl(270, 70%, 60%)',
                        lastShot: 0,
                        attack: function (angle) {
                            game.bullets.push({
                                x: game.player.x,
                                y: game.player.y,
                                radius: 14,
                                color: game.player.color,
                                speed: this.speed,
                                dx: Math.cos(angle),
                                dy: Math.sin(angle),
                                damage: this.damage,
                                hitEnemies: [],
                                secondchance: true,
                            });
                        },
                    },
                    cycle: {
                        name: '순환',
                        basedamage: 50,
                        basecooldown: 3000,
                        basecyclesecond: 1.2,
                        basecycledistance: 200,
                        basecyclecount: 2,
                        basecycleradius: 18,
                        baseEdamage: 50,
                        baseEcyclesecond: 0.6,
                        baseEcycledistance: 400,
                        baseEcycleradius: 18,
                        damage: 50,
                        cooldown: 6000,
                        lastUsed: 0,
                        cyclesecond: 1.2,
                        cycledistance: 200,
                        cyclecount: 2,
                        cycleradius: 18,
                        Edamage: 50,
                        Ecyclesecond: 0.6,
                        Ecycledistance: 400,
                        Ecycleradius: 18,
                        isCycling: false,
                        cycleDuration: 3000,
                        cycleStartTime: 0,
                        circles: [],
                        currentDistance: 100,
                        targetDistance: 100,
                        currentSecond: 2.0,
                        targetSecond: 2.0,
                        angle: 0.0,
                        setup: function () {
                            for (let i = 0; i < this.cyclecount; i++) {
                                this.circles.push({
                                    x: 0,
                                    y: 0,
                                    hitEnemies: [],
                                    hitTimestamps: [], // 적이 피해를 입은 시간 기록
                                });
                            }
                        },
                        attack: function () {
                            const now = Date.now();
                            if (now - this.lastUsed > this.cooldown) {
                                this.isCycling = true;
                                this.cycleStartTime = now;
                                this.lastUsed = now;
                            }
                        },
                        draw: function () {
                            const now = Date.now();
                            const cycleDistance = this.isCycling ? this.Ecycledistance : this.cycledistance;

                            // 회전 범위
                            let closestEnemy = null;
                            let closestDistance = Infinity;

                            game.enemies.forEach(enemy => {
                                const distanceToPlayer = Math.sqrt(
                                    Math.pow(game.player.x - enemy.x, 2) + Math.pow(game.player.y - enemy.y, 2)
                                );
                                if (distanceToPlayer < closestDistance) {
                                    closestDistance = distanceToPlayer;
                                    closestEnemy = enemy;
                                }
                            });

                            if (closestEnemy && closestDistance < cycleDistance - this.cycleradius) {
                                this.targetDistance = closestDistance;
                                this.targetSecond = this.baseEcyclesecond;
                            } else {
                                this.targetSecond = this.isCycling ? this.Ecyclesecond : this.cyclesecond;
                                this.targetDistance = this.isCycling ? this.Ecycledistance : this.cycledistance;
                            }

                            // 점진 값 변화
                            this.currentDistance += (this.targetDistance - this.currentDistance) * 0.2;
                            this.currentSecond += (this.targetSecond - this.currentSecond) * 0.05;

                            for (let i = 0; i < this.cyclecount; i++) {
                                const circle = this.circles[i];
                                if (!circle) continue;
                                for (let j = 0; j < 100; j++) {
                                    this.angle += (2 * Math.PI) / this.currentSecond / 6000;
                                    circle.x =
                                        game.player.x +
                                        Math.cos(this.angle + (2 * i * Math.PI) / this.cyclecount) *
                                            this.currentDistance;
                                    circle.y =
                                        game.player.y +
                                        Math.sin(this.angle + (2 * i * Math.PI) / this.cyclecount) *
                                            this.currentDistance;

                                    // 충돌 체크 및 피해 처리
                                    game.enemies.forEach((enemy, index) => {
                                        if (circle) {
                                            if (
                                                game.utils.circleCollision(
                                                    {
                                                        x: circle.x,
                                                        y: circle.y,
                                                        radius: this.isCycling ? this.cycleradius : this.Ecycleradius,
                                                    },
                                                    enemy
                                                )
                                            ) {
                                                const now = Date.now();
                                                const lastHitTime = circle.hitTimestamps[enemy.id] || 0;
                                                const hitCooldown = 50;

                                                if (now - lastHitTime > hitCooldown) {
                                                    if (
                                                        this.isCycling &&
                                                        now - this.cycleStartTime <= this.cycleDuration
                                                    ) {
                                                        enemy.health -= this.Edamage;
                                                        enemy.x += (enemy.x - game.player.x) * 0.1;
                                                        enemy.y += (enemy.y - game.player.y) * 0.1;
                                                    } else {
                                                        enemy.health -= this.damage;
                                                        enemy.x += (enemy.x - game.player.x) * 0.1;
                                                        enemy.y += (enemy.y - game.player.y) * 0.1;
                                                    }

                                                    circle.hitTimestamps[enemy.id] = now;

                                                    if (enemy.health <= 0) {
                                                        enemy.handleDeath(index);
                                                    } else {
                                                        enemy.healthBarVisible = true;
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                                ctx.beginPath();
                                ctx.arc(circle.x, circle.y, this.cycleradius, 0, Math.PI * 2);
                                ctx.fillStyle =
                                    now - this.lastUsed > this.cooldown ? 'hsl(220, 70%, 75%)' : 'hsl(0, 70%, 75%)';
                                ctx.fill();
                                ctx.strokeStyle = 'hsl(230, 70%, 75%)';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                                ctx.closePath();
                            }

                            if (this.isCycling && now - this.cycleStartTime > this.cycleDuration) {
                                this.isCycling = false;
                            }
                        },
                    },
                    strongshot: {
                        name: '강한 샷',
                        basedamage: 200,
                        basespeed: 12,
                        basecooldown: 1000,
                        baseexplosiverange: 75,
                        damage: 200,
                        speed: 12,
                        cooldown: 1000,
                        color: 'hsl(10, 80%, 50%)',
                        lastShot: 0,
                        pierce: 1000,
                        explosiverange: 75,
                        maxReflections: 0,
                        reflectionpierce: 0,
                        attack: function (angle) {
                            game.bullets.push({
                                x: game.player.x,
                                y: game.player.y,
                                radius: 18,
                                color: game.player.color,
                                speed: this.speed,
                                dx: Math.cos(angle),
                                dy: Math.sin(angle),
                                damage: this.damage,
                                pierce: this.pierce,
                                reflections: 0,
                                maxReflections: this.maxReflections,
                                reflectionpierce: this.reflectionpierce,
                                explosive: 'strongshot',
                                hitEnemies: [],
                            });
                        },
                    },
                    tripleimpact: {
                        name: "세번 충격",
                        basedamage: 80,
    basespeed: 12,
    basecooldown: 700,
    baseexplosiverange: 75,
    baseexplosiveroutine: [5,17,30],
    baseradius: 15,
    damage: 80,
    speed: 12,
    cooldown: 700,
    color: "hsl(200, 80%, 50%)",
    lastShot: 0,
    explosiverange: 75,
    explosiveroutine: [5,17,30],
    maxlifetime: 61,
    radius: 15,
    attack: function(angle) {
        let bullet = {
            x: game.player.x,
            y: game.player.y,
            radius: this.radius,
            color: game.player.color,
            speed: this.speed,
            dx: Math.cos(angle),
            dy: Math.sin(angle),
            damage: this.damage,
            lifetime: 0,
            maxlifetime: this.maxlifetime,
            explosive: "tripleimpact",
        };
        game.bullets.push(bullet);
    }
                    },
                },

                enemies: [],
                bullets: [],
                enemyBullets: [],

                utils: {
                    lineCircleCollision: function (laser, circle) {
                        const x1 = laser.x;
                        const y1 = laser.y;
                        const x2 = laser.x + laser.dx * 2000;
                        const y2 = laser.y + laser.dy * 2000;

                        const cx = circle.x;
                        const cy = circle.y;
                        const r = circle.radius + laser.width / 2;

                        const dx = x2 - x1;
                        const dy = y2 - y1;
                        const fx = x1 - cx;
                        const fy = y1 - cy;

                        const a = dx * dx + dy * dy;
                        const b = 2 * (fx * dx + fy * dy);
                        const c = fx * fx + fy * fy - r * r;

                        let discriminant = b * b - 4 * a * c;

                        if (discriminant < 0) {
                            return false;
                        } else {
                            discriminant = Math.sqrt(discriminant);
                            const t1 = (-b - discriminant) / (2 * a);
                            const t2 = (-b + discriminant) / (2 * a);

                            if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
                                return true;
                            }
                            return false;
                        }
                    },
                    getClosestCharger: function (currentCharger, chargers) {
                        let closestCharger = null;
                        let closestDist = Infinity;
                        chargers.forEach(charger => {
                            let dx = charger.x - currentCharger.x;
                            let dy = charger.y - currentCharger.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < closestDist) {
                                closestCharger = charger;
                                closestDist = dist;
                            }
                        });
                        return closestCharger;
                    },
                    circleCollision: function (circle1, circle2, radius = 0) {
                        let dx = circle1.x - circle2.x;
                        let dy = circle1.y - circle2.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        return distance < circle1.radius + circle2.radius + radius;
                    },
                    circleCollisionOfMonstrance: function (circle1, circle2, radius = 0) {
                        let dx = circle1.x - circle2.x;
                        let dy = circle1.y - circle2.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        return distance < circle1.radius + circle2.radius + radius;
                    },
                    getClosestEnemy: function (currentEnemy, enemies) {
                        let closestEnemy = null;
                        let closestDist = Infinity;
                        enemies.forEach(enemy => {
                            if (enemy !== currentEnemy) {
                                let dx = enemy.x - currentEnemy.x;
                                let dy = enemy.y - currentEnemy.y;
                                let dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < closestDist) {
                                    closestEnemy = enemy;
                                    closestDist = dist;
                                }
                            }
                        });
                        return closestEnemy;
                    },
                    separateEnemies: function () {
                        for (let i = 0; i < game.enemies.length; i++) {
                            for (let j = i + 1; j < game.enemies.length; j++) {
                                let enemy1 = game.enemies[i];
                                let enemy2 = game.enemies[j];
                                let dx = enemy2.x - enemy1.x;
                                let dy = enemy2.y - enemy1.y;
                                let dist = Math.sqrt(dx * dx + dy * dy);
                                let minDist = enemy1.radius + enemy2.radius;
                                if (dist < minDist) {
                                    let angle = Math.atan2(dy, dx);
                                    let overlap = minDist - dist;
                                    enemy1.x -= (overlap * Math.cos(angle)) / 2;
                                    enemy1.y -= (overlap * Math.sin(angle)) / 2;
                                    enemy2.x += (overlap * Math.cos(angle)) / 2;
                                    enemy2.y += (overlap * Math.sin(angle)) / 2;

                                    enemy1.x = Math.max(
                                        enemy1.radius,
                                        Math.min(canvas.width - enemy1.radius, enemy1.x)
                                    );
                                    enemy1.y = Math.max(
                                        enemy1.radius,
                                        Math.min(canvas.height - enemy1.radius, enemy1.y)
                                    );
                                    enemy2.x = Math.max(
                                        enemy2.radius,
                                        Math.min(canvas.width - enemy2.radius, enemy2.x)
                                    );
                                    enemy2.y = Math.max(
                                        enemy2.radius,
                                        Math.min(canvas.height - enemy2.radius, enemy2.y)
                                    );
                                }
                            }
                        }
                    },
                },

                effects: {
                    swordEffect: null,
                    effectsList: [],
                    createExplosionEffect: function (x, y, radius) {
                        this.effectsList.push({
                            x: x,
                            y: y,
                            radius: radius,
                            duration: 20,
                            color: 'rgba(255, 0, 0, 0.5)',
                        });
                    },
                    createSwordEffect: function (x, y, radius) {
                        this.swordEffect = {
                            x: x,
                            y: y,
                            radius: radius,
                            duration: 10,
                        };
                    },
                    drawEffects: function () {
                        if (this.swordEffect) {
                            ctx.beginPath();
                            ctx.arc(this.swordEffect.x, this.swordEffect.y, this.swordEffect.radius, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(0, 128, 255, 0.5)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            ctx.closePath();
                            this.swordEffect.duration--;
                            if (this.swordEffect.duration <= 0) {
                                this.swordEffect = null;
                            }
                        }

                        this.effectsList.forEach((effect, index) => {
                            if (effect.duration > 0) {
                                ctx.beginPath();
                                ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                                ctx.strokeStyle = effect.color;
                                ctx.lineWidth = 5;
                                ctx.stroke();
                                ctx.closePath();
                                effect.duration--;
                            } else {
                                this.effectsList.splice(index, 1);
                            }
                        });
                    },
                    createDeathEffect: function (x, y) {
                        this.effectsList.push({
                            x: x,
                            y: y,
                            radius: 30,
                            color: 'yellow',
                            duration: 15,
                        });
                    },
                },

                enemyTypes: {
                    basic: {
                        radius: 20,
                        color: 'hsl(0, 70%, 60%)',
                        health: 100,
                        maxHealth: 100,
                        speed: 1.5,
                        type: 'basic',
                        shootCooldown: 45,
                        spawnRate: 2,
                        scoreValue: 40,
                        bodyStrength: 1.5,
                        borderResis: 0,
                        move: function (enemy) {
                            let dx = game.player.x - enemy.x;
                            let dy = game.player.y - enemy.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist - (enemy.radius + 20) > 70) {
                                enemy.x += (dx / dist) * enemy.speed;
                                enemy.y += (dy / dist) * enemy.speed;
                            }
                            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                        },
                        attack: function (enemy) {
                            if (enemy.shootCooldown <= 0) {
                                let dx = game.player.x - enemy.x;
                                let dy = game.player.y - enemy.y;
                                let angle = Math.atan2(dy, dx);
                                game.enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    radius: 5,
                                    color: enemy.color,
                                    speed: 5,
                                    dx: Math.cos(angle),
                                    dy: Math.sin(angle),
                                    damage: 5,
                                });
                                enemy.shootCooldown = enemy.shootCooldownValue;
                            } else {
                                enemy.shootCooldown--;
                            }
                        },
                        handleDeath: function (index) {
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                    fast: {
                        radius: 15,
                        color: 'hsl(60, 70%, 60%)',
                        health: 80,
                        maxHealth: 100,
                        speed: 2,
                        type: 'fast',
                        shootCooldown: 90,
                        damage: 5,
                        spawnRate: 1,
                        scoreValue: 60,
                        bodyStrength: 0.5,
                        borderResis: 0,
                        move: function (enemy) {
                            let dx = game.player.x - enemy.x;
                            let dy = game.player.y - enemy.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist - (enemy.radius + 20) > 70) {
                                enemy.x += (dx / dist) * enemy.speed;
                                enemy.y += (dy / dist) * enemy.speed;
                            }
                            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                        },
                        attack: function (enemy) {
                            if (enemy.shootCooldown <= 0) {
                                let dx = game.player.x - enemy.x;
                                let dy = game.player.y - enemy.y;
                                let angle = Math.atan2(dy, dx);
                                let spread = 0.2;
                                for (let i = -1; i <= 1; i++) {
                                    game.enemyBullets.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        radius: 5,
                                        color: enemy.color,
                                        speed: 5,
                                        dx: Math.cos(angle + i * spread),
                                        dy: Math.sin(angle + i * spread),
                                        damage: enemy.damage,
                                    });
                                }
                                enemy.shootCooldown = enemy.shootCooldownValue;
                            } else {
                                enemy.shootCooldown--;
                            }
                        },
                        handleDeath: function (index) {
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                    tank: {
                        radius: 25,
                        color: 'hsl(300, 70%, 60%)',
                        health: 150,
                        maxHealth: 150,
                        speed: 2,
                        type: 'tank',
                        shootCooldown: 120,
                        spawnRate: 1,
                        scoreValue: 60,
                        bodyStrength: 2,
                        borderResis: 0,
                        move: function (enemy) {
                            let dx = game.player.x - enemy.x;
                            let dy = game.player.y - enemy.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist - (enemy.radius + 20) > 70) {
                                enemy.x += (dx / dist) * enemy.speed;
                                enemy.y += (dy / dist) * enemy.speed;
                            }
                            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                        },
                        attack: function (enemy) {
                            if (enemy.shootCooldown <= 0) {
                                let dx = game.player.x - enemy.x;
                                let dy = game.player.y - enemy.y;
                                let angle = Math.atan2(dy, dx);
                                game.enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    radius: 5,
                                    color: enemy.color,
                                    speed: 5,
                                    dx: Math.cos(angle),
                                    dy: Math.sin(angle),
                                    damage: 5,
                                });
                                enemy.shootCooldown = enemy.shootCooldownValue;
                            } else {
                                enemy.shootCooldown--;
                            }
                        },
                        handleDeath: function (index) {
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                    sniper: {
                        radius: 20,
                        color: 'hsl(45, 70%, 60%)',
                        health: 80,
                        maxHealth: 80,
                        speed: 0,
                        type: 'sniper',
                        shootCooldown: 180,
                        damage: 30,
                        spawnRate: 0.7,
                        scoreValue: 70,
                        bodyStrength: 1,
                        borderResis: 0,
                        move: function (enemy) {
                            // 스나는 안움직임
                        },
                        attack: function (enemy) {
                            if (enemy.shootCooldown <= 0) {
                                enemy.targetLineVisible = true;
                                setTimeout(() => {
                                    if (game.enemies.includes(enemy)) {
                                        enemy.targetLineVisible = false;
                                        let dx = game.player.x - enemy.x;
                                        let dy = game.player.y - enemy.y;
                                        let angle = Math.atan2(dy, dx);
                                        game.enemyBullets.push({
                                            x: enemy.x,
                                            y: enemy.y,
                                            radius: 3,
                                            color: enemy.color,
                                            speed: 15,
                                            dx: Math.cos(angle),
                                            dy: Math.sin(angle),
                                            damage: enemy.damage,
                                        });
                                    }
                                }, 500);
                                enemy.shootCooldown = enemy.shootCooldownValue;
                            } else {
                                enemy.shootCooldown--;
                            }
                        },
                        handleDeath: function (index) {
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                    buffer: {
                        radius: 18,
                        color: 'hsl(180, 70%, 60%)',
                        health: 100,
                        maxHealth: 100,
                        speed: 1.5,
                        type: 'buffer',
                        shootCooldown: 1,
                        spawnRate: 0.5,
                        scoreValue: 60,
                        bodyStrength: 1.2,
                        borderResis: 0,
                        move: function (enemy) {
                            let target = game.utils.getClosestEnemy(
                                enemy,
                                game.enemies.filter(e => e.speed > 0 && !e.isBuffed && e !== enemy)
                            );
                            if (!target) {
                                target = game.player;
                            }

                            if (target) {
                                let dx = target.x - enemy.x;
                                let dy = target.y - enemy.y;
                                let dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 70) {
                                    enemy.x += (dx / dist) * enemy.speed;
                                    enemy.y += (dy / dist) * enemy.speed;
                                }
                                enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                                enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                            }
                        },
                        attack: function (enemy) {
                            if (enemy.shootCooldown <= 0) {
                                let target = game.utils.getClosestEnemy(
                                    enemy,
                                    game.enemies.filter(e => e.speed > 0 && !e.isBuffed && e !== enemy)
                                );

                                if (!target) {
                                    target = game.utils.getClosestEnemy(
                                        enemy,
                                        game.enemies.filter(e => e.speed === 0 && !e.isBuffed && e !== enemy)
                                    );
                                }

                                if (!target) {
                                    target = game.player;
                                }

                                if (target && game.utils.circleCollision(enemy, target, 100)) {
                                    target.speed *= 1.25;
                                    target.isBuffed = true;
                                    target.buffDuration = 120;
                                }
                                enemy.shootCooldown = enemy.shootCooldownValue;
                            } else {
                                enemy.shootCooldown--;
                            }
                        },
                        handleDeath: function (index) {
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                    explosive: {
                        radius: 15,
                        color: 'hsl(30, 100%, 50%)',
                        health: 5,
                        maxHealth: 5,
                        speed: 3,
                        type: 'explosive',
                        damage: 15,
                        spawnRate: 0.75,
                        bodyStrength: 0.35,
                        borderResis: 0,
                        hasExploded: false,
                        move: function (enemy) {
                            let dx = game.player.x - enemy.x;
                            let dy = game.player.y - enemy.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 20) {
                                enemy.x += (dx / dist) * enemy.speed;
                                enemy.y += (dy / dist) * enemy.speed;
                            }
                            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));

                            // 충돌 시 폭발
                            if (game.utils.circleCollision(enemy, game.player) && !enemy.hasExploded) {
                                game.handleExplosion(enemy.x, enemy.y, enemy.damage, 'enemy');
                                enemy.hasExploded = true;
                                enemy.health = 0;
                            }
                        },
                        attack: function (enemy) {
                            // 폭발 적은 공격하지 않음
                        },
                        handleDeath: function (index) {
                            if (!this.hasExploded) {
                                game.handleExplosion(this.x, this.y, this.damage, 30, 'enemy');
                                this.hasExploded = true;
                            }
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                        },
                    },
                    debuffer: {
                        radius: 20,
                        color: 'hsl(90, 70%, 60%)',
                        health: 100,
                        maxHealth: 100,
                        speed: 1.5,
                        type: 'debuffer',
                        shootCooldown: 90,
                        spawnRate: 0.7,
                        scoreValue: 70,
                        bodyStrength: 1.3,
                        borderResis: 0,
                        move: function (enemy) {
                            let dx = game.player.x - enemy.x;
                            let dy = game.player.y - enemy.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < 300) {
                                enemy.x -= (dx / dist) * enemy.speed;
                                enemy.y -= (dy / dist) * enemy.speed;
                            } else {
                                let closestEnemy = game.utils.getClosestEnemy(
                                    enemy,
                                    game.enemies.filter(
                                        e =>
                                            e.speed > 0 &&
                                            !['assassin', 'buffer', 'debuffer', 'sniper'].includes(e.type)
                                    )
                                );
                                if (closestEnemy) {
                                    let edx = closestEnemy.x - enemy.x;
                                    let edy = closestEnemy.y - enemy.y;
                                    let edist = Math.sqrt(edx * edx + edy * edy);
                                    if (edist > 20 + enemy.radius + closestEnemy.radius) {
                                        enemy.x += (edx / edist) * enemy.speed;
                                        enemy.y += (edy / edist) * enemy.speed;
                                    }
                                }
                            }

                            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                        },
                        attack: function (enemy) {
                            if (enemy.shootCooldown <= 0) {
                                let dx = game.player.x - enemy.x;
                                let dy = game.player.y - enemy.y;
                                let angle = Math.atan2(dy, dx);
                                game.enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    radius: 5,
                                    color: enemy.color,
                                    speed: 5,
                                    dx: Math.cos(angle),
                                    dy: Math.sin(angle),
                                    damage: 5,
                                    effect: 'slow',
                                    debuffColor: enemy.color,
                                });
                                enemy.shootCooldown = enemy.shootCooldownValue;
                            } else {
                                enemy.shootCooldown--;
                            }
                        },
                        handleDeath: function (index) {
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                    assassin: {
                        radius: 18,
                        color: 'hsl(0, 0%, 60%)',
                        health: 80,
                        maxHealth: 80,
                        speed: 2.5,
                        type: 'assassin',
                        shootCooldown: 0,
                        damage: 15,
                        spawnRate: 1,
                        scoreValue: 70,
                        bodyStrength: 0.8,
                        borderResis: 0,
                        move: function (enemy, index) {
                            let dx = game.player.x - enemy.x;
                            let dy = game.player.y - enemy.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < 200) {
                                enemy.x += (dx / dist) * enemy.speed * 5;
                                enemy.y += (dy / dist) * enemy.speed * 5;
                                if (game.utils.circleCollision(game.player, enemy)) {
                                    if (!game.player.isParrying && !game.player.isDashing) {
                                        game.player.health -= enemy.damage;
                                        game.player.color = 'white';
                                        game.player.hitDuration = 10;
                                    }
                                }
                            } else {
                                enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                                enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                            }
                        },
                        attack: function (enemy) {
                            // 암살자는 기본적으로 안움직임
                        },
                        handleDeath: function (index) {
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                    splitter: {
                        radius: 40,
                        color: 'hsl(30, 50%, 40%)',
                        health: 200,
                        maxHealth: 200,
                        speed: 1,
                        type: 'splitter',
                        splitCount: 2,
                        spawnRate: 0.5,
                        scoreValue: 15,
                        bodyStrength: 3,
                        borderResis: 0,
                        move: function (enemy) {
                            let dx = game.player.x - enemy.x;
                            let dy = game.player.y - enemy.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist - (enemy.radius + 20) > 70) {
                                enemy.x += (dx / dist) * enemy.speed;
                                enemy.y += (dy / dist) * enemy.speed;
                            }
                            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
                        },
                        attack: function (enemy) {
                            // 분열적은 공격하지 않음
                        },
                        handleDeath: function (index) {
                            if (this.splitCount > 0) {
                                for (let i = 0; i < 2; i++) {
                                    game.enemies.push({
                                        x: this.x + (Math.random() - 0.5) * this.radius,
                                        y: this.y + (Math.random() - 0.5) * this.radius,
                                        radius: this.radius / 1.75,
                                        color: this.color,
                                        health: this.maxHealth / 2,
                                        maxHealth: this.maxHealth / 2,
                                        speed: this.speed * 1.5,
                                        type: 'splitter',
                                        splitCount: this.splitCount - 1,
                                        shootCooldownValue: this.shootCooldownValue,
                                        shootCooldown: 0,
                                        scoreValue: 15,
                                        healthBarVisible: false,
                                        bodyStrength: this.bodyStrength - 1,
                                        borderResis: 0,
                                        move: game.enemyTypes.splitter.move,
                                        attack: game.enemyTypes.splitter.attack,
                                        handleDeath: game.enemyTypes.splitter.handleDeath,
                                    });
                                }
                            }
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                    charger: {
                        radius: 20,
                        color: 'hsl(210, 70%, 60%)',
                        health: 100,
                        maxHealth: 100,
                        speed: 0,
                        type: 'charger',
                        shootCooldown: 300,
                        damage: 10,
                        spawnRate: 0.75,
                        scoreValue: 80,
                        bodyStrength: 0.7,
                        borderResis: 0,
                        move: function (enemy) {
                            // 차저는 움직이지 않음
                        },
                        attack: function (enemy) {
                            if (enemy.shootCooldown <= 0) {
                                let closestCharger = game.utils.getClosestCharger(
                                    enemy,
                                    game.enemies.filter(e => e.type === 'charger' && e !== enemy)
                                );
                                if (closestCharger) {
                                    let dx = closestCharger.x - enemy.x;
                                    let dy = closestCharger.y - enemy.y;
                                    let angle = Math.atan2(dy, dx);
                                    game.enemyBullets.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        radius: 5,
                                        color: 'hsl(210, 70%, 80%)',
                                        speed: 25,
                                        dx: Math.cos(angle),
                                        dy: Math.sin(angle),
                                        damage: enemy.damage,
                                        target: closestCharger,
                                        hitChargers: [enemy],
                                    });
                                } else {
                                    let dx = game.player.x - enemy.x;
                                    let dy = game.player.y - enemy.y;
                                    let angle = Math.atan2(dy, dx);
                                    game.enemyBullets.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        radius: 5,
                                        color: 'hsl(210, 70%, 80%)',
                                        speed: 25,
                                        dx: Math.cos(angle),
                                        dy: Math.sin(angle),
                                        damage: enemy.damage,
                                        target: game.player,
                                        hitChargers: [],
                                    });
                                }
                                enemy.shootCooldown = enemy.shootCooldownValue;
                            } else {
                                enemy.shootCooldown--;
                            }
                        },

                        handleDeath: function (index) {
                            game.effects.createDeathEffect(this.x, this.y);
                            game.enemies.splice(index, 1);
                            score += this.scoreValue;
                        },
                    },
                },

                spawnEnemy: function () {
                    let availableTypes = [];
                    if (stage >= 1) availableTypes.push('basic');
                    if (stage >= 2) availableTypes.push('fast');
                    if (stage >= 3) availableTypes.push('tank');
                    if (stage >= 4) availableTypes.push('sniper');
                    if (stage >= 5) availableTypes.push('buffer');
                    if (stage >= 6) availableTypes.push('explosive');
                    if (stage >= 7) availableTypes.push('debuffer');
                    if (stage >= 8) availableTypes.push('assassin');
                    if (stage >= 9) availableTypes.push('splitter');
                    if (stage >= 10) availableTypes.push('charger');

                    function shouldSpawnAdditionalEnemy(probability) {
                        return Math.random() < probability;
                    }

                    let spawnCount = 1;
                    while (shouldSpawnAdditionalEnemy(0.3)) {
                        spawnCount++;
                    }

                    for (let i = 0; i < spawnCount; i++) {
                        let enemyType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                        game.currentEnemyType = enemyType;

                        let x, y;
                        do {
                            x = Math.random() * canvas.width;
                            y = Math.random() * canvas.height;
                        } while (Math.sqrt((x - game.player.x) ** 2 + (y - game.player.y) ** 2) < 200);

                        const enemy = {
                            x: x,
                            y: y,
                            ...game.enemyTypes[enemyType],
                            shootCooldownValue: game.enemyTypes[enemyType].shootCooldown,
                            shootCooldown: game.enemyTypes[enemyType].shootCooldown,
                            healthBarVisible: false,
                        };
                        game.enemies.push(enemy);
                    }
                },

                updateSummonSpeed: function () {
                    if (game.summonSpeed >= 20) {
                        game.summonSpeed -= 2;
                    } else if (20 > game.summonSpeed >= 3) {
                        game.summonSpeed -= 0.4;
                    } else if (3 > game.summonSpeed > game.minSummonSpeed) {
                        game.summonSpeed -= 0.02;
                    }
                },

                updateGame: function () {
                    game.player.update();
                    if (mouseDown) {
                        game.player.attack();
                    }

                    if (mouseDown2) {
                        game.player.attack();
                    }

                    if (game.player.weapon.name === '순환') {
                        game.weapons.cycle.setup();
                    }

                    game.bullets.forEach((bullet, index) => {
                        bullet.x += bullet.dx * bullet.speed * gameSpeed;
                        bullet.y += bullet.dy * bullet.speed * gameSpeed;
                        bullet.timeToLive -= 0.25;
                        if (game.player.weapon.name === '자동의') {
                            bullet.damage = bullet.damage * (bullet.timeToLive / 100);
                        }

                        if (bullet.target && !game.enemies.includes(bullet.target)) {
                            bullet.target = null;
                        }

                        if (bullet.target) {
                            const dx = bullet.target.x - bullet.x;
                            const dy = bullet.target.y - bullet.y;
                            const angle = Math.atan2(dy, dx);
                            bullet.dx = Math.cos(angle);
                            bullet.dy = Math.sin(angle);
                        }

                        if (bullet.x - bullet.radius <= 0 || bullet.x + bullet.radius >= canvas.width) {
                            if (bullet.reflections < game.weapons.strongshot.maxReflections) {
                                bullet.dx *= -1;
                                bullet.pierce = bullet.reflectionpierce;
                                bullet.reflections++;
                            }
                        } else if (bullet.y - bullet.radius <= 0 || bullet.y + bullet.radius >= canvas.height) {
                            if (bullet.reflections < game.weapons.strongshot.maxReflections) {
                                bullet.dy *= -1;
                                bullet.pierce = bullet.reflectionpierce;
                                bullet.reflections++;
                            }
                        }

                        if (game.player.weapon.name === '세번 충격') {
                            bullet.lifetime++;
                            if (bullet.lifetime == game.weapons.tripleimpact.explosiveroutine[0]) {
                                game.handleExplosion(bullet.x, bullet.y, bullet.damage, game.weapons.tripleimpact.explosiverange, 'weapon', bullet.explosive);
                            } else if (bullet.lifetime == game.weapons.tripleimpact.explosiveroutine[1]) {
                                game.handleExplosion(bullet.x, bullet.y, bullet.damage * 1.5, game.weapons.tripleimpact.explosiverange * 1.75, 'weapon', bullet.explosive);
                            } else if (bullet.lifetime == game.weapons.tripleimpact.explosiveroutine[2]) {
                                game.handleExplosion(bullet.x, bullet.y, bullet.damage * 2, game.weapons.tripleimpact.explosiverange * 2.5, 'weapon', bullet.explosive);
                                game.bullets.splice(index, 1);
                            }
                        }

                        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                            if (bullet.explosive) {
                                if (bullet.explosive === 'burst') {
                                    game.handleExplosion(bullet.x, bullet.y, bullet.damage, game.weapons.burst.explosiverange, 'weapon', bullet.explosive);
                                } else if (bullet.explosive === 'dual') {
                                    game.handleExplosion(bullet.x, bullet.y, bullet.damage, game.weapons.dual.explosiverange, 'weapon', bullet.explosive);
                                } else if (bullet.explosive === 'strongshot') {
                                    game.handleExplosion(bullet.x, bullet.y, bullet.damage, game.weapons.strongshot.explosiverange, 'weapon', bullet.explosive);
                                }
                            }
                            game.bullets.splice(index, 1);
                        } else {
                            for (let enemyIndex = game.enemies.length - 1; enemyIndex >= 0; enemyIndex--) {
                                const enemy = game.enemies[enemyIndex];
                                if (
                                    game.utils.circleCollision(bullet, enemy) &&
                                    (!bullet.hitEnemies || !bullet.hitEnemies.includes(enemy))
                                ) {
                                    if (!bullet.originalDamage) {
                                        bullet.originalDamage = bullet.damage;
                                    }
                                    enemy.health -= bullet.damage;
                                    if (!bullet.hitEnemies) {
                                        bullet.hitEnemies = [];
                                    }
                                    bullet.hitEnemies.push(enemy);
                                    console.log(`공격 대미지: ${bullet.damage}`);
                                    if (enemy.health <= 0) {
                                        if (bullet.absorb) {
                                            game.player.health = Math.min(
                                                game.player.health + game.player.maxHealth * 0.0025,
                                                game.player.maxHealth
                                            );
                                        }
                                        enemy.handleDeath(enemyIndex);
                                    }

                                    if (bullet.absorb) {
                                        game.player.maxHealth += game.weapons.absorb.valueMax;
                                        game.player.health += game.weapons.absorb.value;
                                    }

                                    if (bullet.chain && bullet.chain > 0) {
                                        bullet.chain--;
                                        const closestEnemy = game.utils.getClosestEnemy(
                                            enemy,
                                            game.enemies.filter(
                                                e =>
                                                    e !== enemy &&
                                                    (!bullet.hitEnemies || !bullet.hitEnemies.includes(e))
                                            )
                                        );
                                        if (
                                            closestEnemy &&
                                            game.utils.circleCollision(
                                                {
                                                    x: bullet.x,
                                                    y: bullet.y,
                                                    radius: 0,
                                                },
                                                closestEnemy,
                                                500
                                            )
                                        ) {
                                            const angle = Math.atan2(
                                                closestEnemy.y - bullet.x,
                                                closestEnemy.x - bullet.x
                                            );
                                            //const newDamage = bullet.damage - (bullet.originalDamage / (game.weapons.chain.chaincount * 2));
                                            const newDamage = bullet.damage + bullet.originalDamage * 0.25;
                                            game.bullets.push({
                                                x: enemy.x,
                                                y: enemy.y,
                                                radius: bullet.radius,
                                                color: bullet.color,
                                                speed: bullet.speed,
                                                dx: Math.cos(angle),
                                                dy: Math.sin(angle),
                                                damage: newDamage,
                                                chain: bullet.chain,
                                                hitEnemies: [...bullet.hitEnemies],
                                                target: closestEnemy,
                                                originalDamage: bullet.originalDamage,
                                            });
                                        } else {
                                            bullet.chain = 0;
                                        }
                                    }

                                    if (bullet.explosive) {
                                        if (bullet.explosive === 'burst') {
                                            game.handleExplosion(bullet.x, bullet.y, bullet.damage, game.weapons.burst.explosiverange, 'weapon', bullet.explosive);
                                        } else if (bullet.explosive === 'dual') {
                                            game.handleExplosion(bullet.x, bullet.y, bullet.damage, game.weapons.dual.explosiverange, 'weapon', bullet.explosive);
                                        } else if (bullet.explosive === 'strongshot') {
                                            game.handleExplosion(bullet.x, bullet.y, bullet.damage, game.weapons.strongshot.explosiverange, 'weapon', bullet.explosive);
                                        }
                                    }

                                    if (bullet.secondchance) {
                                        game.handleLaser(
                                            bullet.x,
                                            bullet.y,
                                            bullet.dx,
                                            bullet.dy,
                                            game.weapons.secondchance.laserdamage,
                                            bullet.hitEnemies
                                        );
                                    }

                                    if (bullet.pierce > 0) {
                                        bullet.pierce--;
                                    } else {
                                        game.bullets.splice(index, 1);
                                    }

                                    enemy.healthBarVisible = true;
                                    break;
                                }
                            }
                        }
                    });

                    game.lasers.forEach((laser, index) => {
                        laser.duration -= gameSpeed;
                        if (laser.duration <= 0) {
                            game.lasers.splice(index, 1);
                        } else {
                            game.enemies.forEach((enemy, enemyIndex) => {
                                if (!laser.hitEnemies.includes(enemy) && game.utils.lineCircleCollision(laser, enemy)) {
                                    enemy.health -= laser.damage;
                                    laser.hitEnemies.push(enemy);
                                    if (enemy.health <= 0) {
                                        enemy.handleDeath(enemyIndex);
                                    }
                                    enemy.healthBarVisible = true;
                                }
                            });
                        }
                    });

                    game.effects.drawEffects();

                    game.enemyBullets.forEach((bullet, index) => {
                        bullet.x += bullet.dx * bullet.speed * gameSpeed;
                        bullet.y += bullet.dy * bullet.speed * gameSpeed;

                        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                            game.enemyBullets.splice(index, 1);
                        } else {
                            if (
                                bullet.target &&
                                bullet.hitChargers.length < game.enemies.filter(e => e.type === 'charger').length
                            ) {
                                const dx = bullet.target.x - bullet.x;
                                const dy = bullet.target.y - bullet.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist < bullet.speed) {
                                    bullet.hitChargers.push(bullet.target);

                                    const newTarget = game.utils.getClosestCharger(
                                        bullet.target,
                                        game.enemies.filter(
                                            e => e.type === 'charger' && !bullet.hitChargers.includes(e)
                                        )
                                    );
                                    if (newTarget) {
                                        bullet.target = newTarget;
                                        const angle = Math.atan2(newTarget.y - bullet.y, newTarget.x - bullet.x);
                                        bullet.dx = Math.cos(angle);
                                        bullet.dy = Math.sin(angle);
                                    } else {
                                        bullet.target = game.player;
                                        const angle = Math.atan2(game.player.y - bullet.y, game.player.x - bullet.x);
                                        bullet.dx = Math.cos(angle);
                                        bullet.dy = Math.sin(angle);
                                    }

                                    bullet.radius += 2.5;
                                    bullet.damage += game.enemyTypes.charger.damage;
                                }
                            }

                            if (game.utils.circleCollision(bullet, game.player)) {
                                if (game.player.isParrying) {
                                    game.player.parryDuration = 45;
                                    game.player.parryHits++;
                                    if (bullet.explosive) {
                                        game.handleExplosion(bullet.x, bullet.y, bullet.damage, 30, 'enemy');
                                    }
                                    game.enemyBullets.splice(index, 1);
                                    if (game.player.parryHits >= 10) {
                                        game.player.isParrying = false;
                                        game.player.parryCooldown = game.player.parryHits * 180;
                                        game.player.parryHits = 0;
                                    }
                                } else if (!game.player.isDashing) {
                                    game.player.health -= bullet.damage;
                                    game.player.color = 'white';
                                    game.player.hitDuration = 10;
                                    if (bullet.effect === 'slow') {
                                        game.player.isDebuffed = true;
                                        game.player.debuffColor = bullet.debuffColor;
                                        game.player.speed *= 0.25;
                                        game.player.debuffDuration = 120;
                                    }
                                    if (bullet.explosive) {
                                        game.handleExplosion(bullet.x, bullet.y, bullet.damage, 30, 'enemy');
                                    }
                                    game.enemyBullets.splice(index, 1);
                                }
                            }
                        }
                    });

                    game.enemies.forEach((enemy, index) => {
                        enemy.move(enemy, index);
                        enemy.attack(enemy);
                        if (game.utils.circleCollision(game.player, enemy)) {
                            if (game.player.isParrying) {
                                game.player.parryDuration = 45;
                                game.player.parryHits++;
                                if (!enemy.isDead) {
                                    enemy.isDead = true;
                                    enemy.handleDeath(index);
                                }
                            } else if (!game.player.isDashing) {
                                game.player.health -= 10;
                                game.player.color = 'white';
                                game.player.hitDuration = 10;
                                if (!enemy.isDead) {
                                    enemy.isDead = true;
                                    enemy.handleDeath(index);
                                }
                            }
                        }
                        if (enemy.health <= 0 && !enemy.isDead) {
                            enemy.isDead = true;
                            enemy.handleDeath(index);
                        }
                        if (enemy.isBuffed) {
                            enemy.buffDuration--;
                            if (enemy.buffDuration <= 0) {
                                enemy.speed /= 1.5;
                                enemy.isBuffed = false;
                            }
                        }
                    });

                    game.utils.separateEnemies();

                    score++;
                    if (score % game.summonSpeed === 0) {
                        game.spawnEnemy();
                    }
                    if (score % game.summonSpeed === 0 && score >= 45000) {
                        game.spawnEnemy();
                    }
                    if (score % game.summonSpeed === 0 && score >= 70000) {
                        game.spawnEnemy();
                    }
                    if (score % game.summonSpeed === 0 && score >= 90000) {
                        game.spawnEnemy();
                        game.spawnEnemy();
                    }
                    if (score % game.summonSpeed === 0 && score >= 100000) {
                        game.spawnEnemy();
                        game.spawnEnemy();
                        game.spawnEnemy();
                    }

                    if (score % game.summonSpeedDecreaseInterval === 0) {
                        game.updateSummonSpeed();
                    }
                },

                drawGame: function () {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    ctx.fillStyle = 'gray';
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Stage ${stage}`, canvas.width / 2, 50);

                    game.player.draw();
                    game.player.drawUI();

                    game.weapons.cycle.draw();

                    game.lasers.forEach(laser => {
                        game.drawLaser(laser);
                    });

                    game.enemies.forEach(enemy => {
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                        ctx.fillStyle = enemy.color;
                        ctx.fill();

                        let outlineColor = `hsl(${getHue(enemy.color)}, 70%, ${getLightness(enemy.color) - 20}%)`;
                        if (enemy.isBuffedB) {
                            outlineColor = 'green';
                        } else if (enemy.isBuffed) {
                            outlineColor = 'blue';
                        }
                        ctx.strokeStyle = outlineColor;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.closePath();

                        if (enemy.type === 'sniper' && enemy.targetLineVisible) {
                            ctx.beginPath();
                            ctx.moveTo(enemy.x, enemy.y);
                            ctx.lineTo(game.player.x, game.player.y);
                            ctx.strokeStyle = 'red';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            ctx.closePath();
                        }

                        if (enemy.healthBarVisible) {
                            ctx.fillStyle = 'hsl(0, 70%, 60%)';
                            ctx.fillRect(
                                enemy.x - enemy.radius,
                                enemy.y - enemy.radius - 10,
                                enemy.radius * 2 * (enemy.health / 100),
                                5
                            );
                        }
                    });

                    game.bullets.concat(game.enemyBullets).forEach(bullet => {
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                        ctx.fillStyle = bullet.color;
                        ctx.fill();
                        ctx.strokeStyle = `hsl(${getHue(bullet.color)}, 70%, ${getLightness(bullet.color) - 20}%)`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.closePath();
                    });

                    game.effects.drawEffects();

                    ctx.fillStyle = 'black';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${score}`, canvas.width / 2, 30);
                },

                gameLoop: function () {
                    if (!isGameLoopRunning) {
                        isGameLoopRunning = true;
                        const loop = () => {
                            if (!gamePaused) {
                                game.updateGame();
                                game.drawGame();
                                updateStage();
                                updateNextStageEnemy();
                                requestAnimationFrame(loop);
                            } else {
                                isGameLoopRunning = false;
                            }
                        };
                        loop();
                    }
                },

                reset: function () {
                    game.player.color = game.player.defaultColor;
                    game.player.health = 100;
                    game.player.maxHealth = 100;
                    game.player.x = canvas.width / 2;
                    game.player.y = canvas.height - 30;
                    game.player.isParrying = false;
                    game.player.parryDuration = 0;
                    game.player.parryCooldown = 0;
                    game.player.parryHits = 0;
                    game.player.dashesLeft = 5;
                    game.player.isDashing = false;
                    game.player.dashDuration = 0;
                    game.player.hitDuration = 0;
                    game.player.isDebuffed = false;
                    game.player.debuffColor = null;
                    game.player.debuffDuration = 0;
                    game.player.maxDashes = 5;
                    game.player.speed = game.player.basespeed;
                    game.player.defaultSpeed = game.player.basedefaultSpeed;
                    game.player.weapon = null;
                    collectedItems = [];
                    game.player.lastDanceCount = 0;
                    game.player.lastDanceApplied = false;
                    game.player.has_monstrance = 0;
                    location.reload();

                    // 무기 속성
                    Object.keys(game.weapons).forEach(weaponName => {
                        const weapon = game.weapons[weaponName];
                        weapon.damage = weapon.basedamage;
                        weapon.speed = weapon.basespeed;
                        weapon.cooldown = weapon.basecooldown;
                        if (weapon.baserange) {
                            weapon.range = weapon.baserange;
                        }
                        if (weapon.spread) {
                            weapon.spread = weapon.basespread;
                        }
                        if (weapon.baselaserdamage) {
                            weapon.laserdamage = weapon.baselaserdamage;
                        }
                        if (weapon.baselaserthickness) {
                            weapon.laserthickness = weapon.baselaserthickness;
                        }
                        if (weapon.baseexplosiverange) {
                            weapon.explosiverange = weapon.baseexplosiverange;
                        }
                        if (weapon.baseBulletSpacing) {
                            weapon.bulletSpacing = weapon.baseBulletSpacing;
                        }
                        if (weapon.baseBulletRadius) {
                            weapon.bulletRadius = weapon.baseBulletRadius;
                        }
                        if (weapon.basecooldown) {
                            weapon.cooldown = weapon.basecooldown;
                        }
                        if (weapon.basecyclecount) {
                            weapon.cyclecount = weapon.basecyclecount;
                        }
                        if (weapon.basecyclesecond) {
                            weapon.cyclesecond = weapon.basecyclesecond;
                        }
                        if (weapon.basecycledistance) {
                            weapon.cycledistance = weapon.basecycledistance;
                        }
                        if (weapon.baseEcyclecount) {
                            weapon.Ecyclecount = weapon.baseEcyclecount;
                        }
                        if (weapon.baseEcyclesecond) {
                            weapon.Ecyclesecond = weapon.baseEcyclesecond;
                        }
                        if (weapon.baseEcycledistance) {
                            weapon.Ecycledistance = weapon.baseEcycledistance;
                        }
                        if (weapon.isCycling) {
                            weapon.isCycling = false;
                        }
                    });

                    game.weapons.multishot.dualSpreadCount = 0;
                    game.enemies = [];
                    game.bullets = [];
                    game.enemyBullets = [];
                    game.lasers = [];
                    game.effects.effectsList = [];
                    game.summonSpeed = 120;
                    game.summonSpeedDecreaseInterval = 100;
                    score = 0;
                    document.getElementById('weaponSelect').style.display = 'block';
                    document.getElementById('functionFive').style.display = 'block';
                    document.getElementById('nextStageEnemy').style.display = 'none';
                    canvas.style.display = 'none';
                    stage = 1;
                    gamePaused = true;
                },
            };

            const weaponDescriptions = {
                multishot: `다중 발사 / MultiShot\n여러 발의 탄환을 동시에 발사합니다.\nDamage ${game.weapons.multishot.damage} × ${game.weapons.multishot.spread}`,
                automatic: `자동의 / Automatic\n날아갈수록 점점 약해지는 탄환을 연사합니다.\nDamage ${game.weapons.automatic.damage}`,
                strike: `내려치기 / Strike\n원하는 지점에 강력한 공격을 가합니다.\nDamage ${game.weapons.strike.damage}`,
                dual: `두개 / Dual\n두 개의 탄환을 동시에 발사하며, 적중 시 폭발합니다.\nDamage ${game.weapons.dual.damage} × 2 / Explode Damage 100% × 2`,
                swing: `휘두르다 / Swing\n근접 범위 내의 모든 적을 공격하며, 탄환을 제거합니다.\nDamage ${game.weapons.swing.damage}`,
                chain: `연쇄 / Chain\n적을 공격하면 주변의 다른 적들에게도 25% 강해진 공격이 최대 4번 연쇄적으로 가해집니다.\nDamage ${game.weapons.chain.damage}`,
                absorb: `흡수 / Absorb\n적중 시 체력 및 최대체력이 소량 증가하며, 적 처치 시시 최대체력의 0.25%를 회복합니다.\nDamage ${game.weapons.absorb.damage}`,
                burst: `터지는 공격 / Burst\n가까울수록 치명적인 거대 폭발을 일으킵니다.\nDamage ${game.weapons.burst.damage}`,
                secondchance: `두번째 기회 / SecondChance\n적중 시 탄환이 거대한 레이저를 발사합니다.\nDamage ${game.weapons.secondchance.damage} / Laser Damage ${game.weapons.secondchance.laserdamage}`,
                cycle: `순환 / Cycle\n순환구가 빠르게 넓은 범위를 3초간 회전합니다.\nDamage ${game.weapons.cycle.damage} × 2`,
                strongshot: `강한 샷 / StrongShot\n적을 관통하는 강력한 탄환을 발사하며, 적중시 작게 폭발합니다.\nDamage ${game.weapons.strongshot.damage} / Explode Damage 50%`,
		tripleimpact: `세번 충격 / TripleImpact\n발사된 탄환이 점점 크게 폭발을 일으킵니다.\nDamage ${game.weapons.tripleimpact.damage} / Explode Damage 100%/150%/200%`,
            };

            function showDescription(weapon) {
                const descriptionDiv = document.getElementById('weaponDescription');
                descriptionDiv.innerText = weaponDescriptions[weapon];
            }

            function hideDescription() {
                const descriptionDiv = document.getElementById('weaponDescription');
                descriptionDiv.innerText = '';
            }

            function getHue(color) {
                if (color && color.match) {
                    let hue = color.match(/\d+/g);
                    if (hue && hue[0]) {
                        return hue[0];
                    }
                }
                return 0;
            }

            function getLightness(color) {
                let matches = color.match(/\d+%/g);
                if (matches && matches[1]) {
                    return matches[1].replace('%', '');
                } else {
                    return '50';
                }
            }

            canvas.addEventListener('mousedown', function (e) {
                if (e.button === 0) {
                    mouseDown = true;
                    game.player.attack();
                } else if (e.button === 2) {
                    mouseDown2 = true;
                    game.player.parry();
                }
            });
            canvas.addEventListener('mouseup', function (e) {
                if (e.button === 0) {
                    mouseDown = false;
                } else if (e.button === 2) {
                    mouseDown2 = false;
                }
            });
            canvas.addEventListener('mousemove', function (e) {
                let rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });

            let isGameOver = false;

            document.addEventListener('keydown', function (e) {
                keys[e.key.toLowerCase()] = true;
                if (e.key === ' ') game.player.dash();
                if (e.key === 'Escape' && gameStarted) {
                    if (isGameOver === true) {
                        return;
                    } else if (selectionModal.style.display === 'block' && pauseModal.style.display === 'block') {
                        pauseModal.style.display = 'none';
                        gamePaused = true;
                        game.gameLoop();
                        return;
                    }
                    togglePause();
                }
            });
            document.addEventListener('keyup', function (e) {
                keys[e.key.toLowerCase()] = false;
            });
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            const pauseModal = document.createElement('div');
            pauseModal.id = 'pauseModal';
            pauseModal.style.display = 'none';
            pauseModal.style.position = 'fixed';
            pauseModal.style.top = '50%';
            pauseModal.style.left = '50%';
            pauseModal.style.transform = 'translate(-50%, -50%)';
            pauseModal.style.background = 'rgba(0, 0, 0, 0.8)';
            pauseModal.style.color = 'white';
            pauseModal.style.padding = '20px';
            pauseModal.style.borderRadius = '10px';
            pauseModal.style.textAlign = 'center';
            document.body.appendChild(pauseModal);

            const collectedItemsDiv = document.createElement('div');
            collectedItemsDiv.id = 'collectedItems';
            collectedItemsDiv.style.marginTop = '20px';
            pauseModal.appendChild(collectedItemsDiv);

            function togglePause() {
                const selectionModal = document.getElementById('selectionModal');
                if (selectionModal.style.display === 'block') {
                    gamePaused = true;
                    pauseModal.style.display = 'block';
                    collectedItemsDiv.innerHTML = '<h2>ㅤ일시정지 / PAUSEㅤ</h2>';

                    const itemCounts = {};

                    collectedItems.forEach(item => {
                        if (!itemCounts[item.name]) {
                            itemCounts[item.name] = 0;
                        }
                        itemCounts[item.name]++;
                    });

                    if (Object.keys(itemCounts).length > 0) {
                        for (let itemName in itemCounts) {
                            const itemElement = document.createElement('p');
                            itemElement.innerText = `${itemName} [ ${itemCounts[itemName]} ]`;

                            const item = collectedItems.find(i => i.name === itemName);
                            switch (item.rarity) {
                                case 'rare':
                                    itemElement.style.color = 'cyan';
                                    break;
                                case 'epic':
                                    itemElement.style.color = 'magenta';
                                    break;
                                case 'legendary':
                                    itemElement.style.color = 'gold';
                                    break;
                                default:
                                    itemElement.style.color = 'white';
                            }

                            itemElement.style.margin = '5px 0';

                            collectedItemsDiv.appendChild(itemElement);
                        }
                    } else {
                        const noItemsElement = document.createElement('p');
                        noItemsElement.innerText = '휙득한 아이템 없음';
                        collectedItemsDiv.appendChild(noItemsElement);
                    }

                    collectedItemsDiv.style.marginBottom = '20px';
                } else {
                    gamePaused = !gamePaused;
                    if (gamePaused) {
                        pauseModal.style.display = 'block';
                        collectedItemsDiv.innerHTML = '<h2>ㅤ일시정지 / PAUSEㅤ</h2>';

                        const itemCounts = {};

                        collectedItems.forEach(item => {
                            if (!itemCounts[item.name]) {
                                itemCounts[item.name] = 0;
                            }
                            itemCounts[item.name]++;
                        });

                        if (Object.keys(itemCounts).length > 0) {
                            for (let itemName in itemCounts) {
                                const itemElement = document.createElement('p');
                                itemElement.innerText = `${itemName} [ ${itemCounts[itemName]} ]`;

                                const item = collectedItems.find(i => i.name === itemName);
                                switch (item.rarity) {
                                    case 'rare':
                                        itemElement.style.color = 'cyan';
                                        break;
                                    case 'epic':
                                        itemElement.style.color = 'magenta';
                                        break;
                                    case 'legendary':
                                        itemElement.style.color = 'gold';
                                        break;
                                    default:
                                        itemElement.style.color = 'white';
                                }

                                itemElement.style.margin = '5px 0';

                                collectedItemsDiv.appendChild(itemElement);
                            }
                        } else {
                            const noItemsElement = document.createElement('p');
                            noItemsElement.innerText = '휙득한 아이템 없음';
                            collectedItemsDiv.appendChild(noItemsElement);
                        }

                        collectedItemsDiv.style.marginBottom = '20px';
                    } else {
                        pauseModal.style.display = 'none';
                        game.gameLoop();
                    }
                }
            }

            const continueButton = document.createElement('button');
            continueButton.innerText = '돌아가기';
            continueButton.onclick = function () {
                if (document.getElementById('selectionModal').style.display === 'block') {
                    pauseModal.style.display = 'none';
                } else {
                    gamePaused = false;
                    pauseModal.style.display = 'none';
                    game.gameLoop();
                }
            };
            pauseModal.appendChild(continueButton);

            const mainmenuButton = document.createElement('button');
            mainmenuButton.innerText = '메인메뉴';
            mainmenuButton.onclick = function () {
                const confirmReturn = confirm('정말로 메인메뉴로 돌아가시겠습니까?');
                if (confirmReturn) {
                    returnToMainMenu();
                }
            };
            pauseModal.appendChild(mainmenuButton);

            function gameOver() {
                gameStarted = false;
                updatePlayerHealthDisplay();
                showGameOverScreen();
            }

            function showGameOverScreen() {
                localStorage.setItem('current', score);
                var bs = localStorage.getItem('best');
                if (bs == null) bs = 0;
                if (score > bs) {
                    alert('최고기록 갱신!');
                    localStorage.setItem('best', score);
                }

                const gameOverModal = document.createElement('div');
                gameOverModal.id = 'gameOverModal';
                gameOverModal.style.position = 'absolute';
                gameOverModal.style.top = '50%';
                gameOverModal.style.left = '50%';
                gameOverModal.style.transform = 'translate(-50%, -50%)';
                gameOverModal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                gameOverModal.style.color = 'white';
                gameOverModal.style.padding = '20px';
                gameOverModal.style.borderRadius = '10px';
                gameOverModal.style.textAlign = 'center';

                isGameOver = true;

                const gameOverText = document.createElement('h2');
                gameOverText.innerText = '게임 오버 / GAME OVER';
                gameOverModal.appendChild(gameOverText);

                const scoreText = document.createElement('p');
                scoreText.innerText = `점수 : ${score}`;
                gameOverModal.appendChild(scoreText);

                const inventoryList = document.createElement('div');
                const itemCounts = {};

                collectedItems.forEach(item => {
                    if (!itemCounts[item.name]) {
                        itemCounts[item.name] = 0;
                    }
                    itemCounts[item.name]++;
                });

                if (Object.keys(itemCounts).length === 0) {
                    const noItemsElement = document.createElement('p');
                    noItemsElement.innerText = '아이템 없음';
                    inventoryList.appendChild(noItemsElement);
                } else {
                    for (let itemName in itemCounts) {
                        const listItem = document.createElement('p');
                        listItem.innerText = `${itemName} [ ${itemCounts[itemName]} ]`;

                        const item = collectedItems.find(i => i.name === itemName);
                        switch (item.rarity) {
                            case 'rare':
                                listItem.style.color = 'cyan';
                                break;
                            case 'epic':
                                listItem.style.color = 'magenta';
                                break;
                            case 'legendary':
                                listItem.style.color = 'gold';
                                break;
                            default:
                                listItem.style.color = 'white';
                        }

                        listItem.style.margin = '5px 0';
                        inventoryList.appendChild(listItem);
                    }
                }

                gameOverModal.appendChild(inventoryList);

                const retryButton = document.createElement('button');
                retryButton.innerText = '확인';
                retryButton.style.marginTop = '20px';
                retryButton.onclick = () => {
                    gameOverModal.remove();
                    gameStarted = false;
                    gamePaused = false;
                    isGameOver = false;
                    game.reset();
                };
                gameOverModal.appendChild(retryButton);

                document.body.appendChild(gameOverModal);

                gamePaused = true;
            }
        </script>
    </body>
</html>
